/*!
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as anonymous module.
		define(['jquery'], factory);
	} else {
		// Browser globals.
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function raw(s) {
		return s;
	}

	function decoded(s) {
		return decodeURIComponent(s.replace(pluses, ' '));
	}

	function converted(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}
		try {
			return config.json ? JSON.parse(s) : s;
		} catch(er) {}
	}

	var config = $.cookie = function (key, value, options) {

		// write
		if (value !== undefined) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setDate(t.getDate() + days);
			}

			value = config.json ? JSON.stringify(value) : String(value);

			return (document.cookie = [
				config.raw ? key : encodeURIComponent(key),
				'=',
				config.raw ? value : encodeURIComponent(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// read
		var decode = config.raw ? raw : decoded;
		var cookies = document.cookie.split('; ');
		var result = key ? undefined : {};
		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = decode(parts.join('='));

			if (key && key === name) {
				result = converted(cookie);
				break;
			}

			if (!key) {
				result[name] = converted(cookie);
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) !== undefined) {
			// Must not alter options, thus extending a fresh object...
			$.cookie(key, '', $.extend({}, options, { expires: -1 }));
			return true;
		}
		return false;
	};

}));;/*
 * qTip2 - Pretty powerful tooltips - v2.2.0
 * http://qtip2.com
 *
 * Copyright (c) 2013 Craig Michael Thompson
 * Released under the MIT, GPL licenses
 * http://jquery.org/license
 *
 * Date: Thu Nov 21 2013 08:34 GMT+0000
 * Plugins: tips modal viewport svg imagemap ie6
 * Styles: basic css3
 */
/*global window: false, jQuery: false, console: false, define: false */

/* Cache window, document, undefined */
(function( window, document, undefined ) {

// Uses AMD or browser globals to create a jQuery plugin.
(function( factory ) {
	"use strict";
	if(typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	}
	else if(jQuery && !jQuery.fn.qtip) {
		factory(jQuery);
	}
}
(function($) {
	"use strict"; // Enable ECMAScript "strict" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/

;// Munge the primitives - Paul Irish tip
var TRUE = true,
FALSE = false,
NULL = null,

// Common variables
X = 'x', Y = 'y',
WIDTH = 'width',
HEIGHT = 'height',

// Positioning sides
TOP = 'top',
LEFT = 'left',
BOTTOM = 'bottom',
RIGHT = 'right',
CENTER = 'center',

// Position adjustment types
FLIP = 'flip',
FLIPINVERT = 'flipinvert',
SHIFT = 'shift',

// Shortcut vars
QTIP, PROTOTYPE, CORNER, CHECKS,
PLUGINS = {},
NAMESPACE = 'qtip',
ATTR_HAS = 'data-hasqtip',
ATTR_ID = 'data-qtip-id',
WIDGET = ['ui-widget', 'ui-tooltip'],
SELECTOR = '.'+NAMESPACE,
INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),

CLASS_FIXED = NAMESPACE+'-fixed',
CLASS_DEFAULT = NAMESPACE + '-default',
CLASS_FOCUS = NAMESPACE + '-focus',
CLASS_HOVER = NAMESPACE + '-hover',
CLASS_DISABLED = NAMESPACE+'-disabled',

replaceSuffix = '_replacedByqTip',
oldtitle = 'oldtitle',
trackingBound,

// Browser detection
BROWSER = {
	/*
	 * IE version detection
	 *
	 * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment
	 * Credit to James Padolsey for the original implemntation!
	 */
	ie: (function(){
		var v = 3, div = document.createElement('div');
		while ((div.innerHTML = '<!--[if gt IE '+(++v)+']><i></i><![endif]-->')) {
			if(!div.getElementsByTagName('i')[0]) { break; }
		}
		return v > 4 ? v : NaN;
	}()),
 
	/*
	 * iOS version detection
	 */
	iOS: parseFloat( 
		('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])
		.replace('undefined', '3_2').replace('_', '.').replace('_', '')
	) || FALSE
};

;function QTip(target, options, id, attr) {
	// Elements and ID
	this.id = id;
	this.target = target;
	this.tooltip = NULL;
	this.elements = { target: target };

	// Internal constructs
	this._id = NAMESPACE + '-' + id;
	this.timers = { img: {} };
	this.options = options;
	this.plugins = {};

	// Cache object
	this.cache = {
		event: {},
		target: $(),
		disabled: FALSE,
		attr: attr,
		onTooltip: FALSE,
		lastClass: ''
	};

	// Set the initial flags
	this.rendered = this.destroyed = this.disabled = this.waiting = 
		this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
}
PROTOTYPE = QTip.prototype;

PROTOTYPE._when = function(deferreds) {
	return $.when.apply($, deferreds);
};

PROTOTYPE.render = function(show) {
	if(this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit

	var self = this,
		options = this.options,
		cache = this.cache,
		elements = this.elements,
		text = options.content.text,
		title = options.content.title,
		button = options.content.button,
		posOptions = options.position,
		namespace = '.'+this._id+' ',
		deferreds = [],
		tooltip;

	// Add ARIA attributes to target
	$.attr(this.target[0], 'aria-describedby', this._id);

	// Create tooltip element
	this.tooltip = elements.tooltip = tooltip = $('<div/>', {
		'id': this._id,
		'class': [ NAMESPACE, CLASS_DEFAULT, options.style.classes, NAMESPACE + '-pos-' + options.position.my.abbrev() ].join(' '),
		'width': options.style.width || '',
		'height': options.style.height || '',
		'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,

		/* ARIA specific attributes */
		'role': 'alert',
		'aria-live': 'polite',
		'aria-atomic': FALSE,
		'aria-describedby': this._id + '-content',
		'aria-hidden': TRUE
	})
	.toggleClass(CLASS_DISABLED, this.disabled)
	.attr(ATTR_ID, this.id)
	.data(NAMESPACE, this)
	.appendTo(posOptions.container)
	.append(
		// Create content element
		elements.content = $('<div />', {
			'class': NAMESPACE + '-content',
			'id': this._id + '-content',
			'aria-atomic': TRUE
		})
	);

	// Set rendered flag and prevent redundant reposition calls for now
	this.rendered = -1;
	this.positioning = TRUE;

	// Create title...
	if(title) {
            
		this._createTitle();

		// Update title only if its not a callback (called in toggle if so)
		if(!$.isFunction(title)) {
			deferreds.push( this._updateTitle(title, FALSE) );
		}
	}

	// Create button
	if(button) { this._createButton(); }

	// Set proper rendered flag and update content if not a callback function (called in toggle)
	if(!$.isFunction(text)) {
		deferreds.push( this._updateContent(text, FALSE) );
	}
	this.rendered = TRUE;

	// Setup widget classes
	this._setWidget();

	// Initialize 'render' plugins
	$.each(PLUGINS, function(name) {
		var instance;
		if(this.initialize === 'render' && (instance = this(self))) {
			self.plugins[name] = instance;
		}
	});

	// Unassign initial events and assign proper events
	this._unassignEvents();
	this._assignEvents();

	// When deferreds have completed
	this._when(deferreds).then(function() {
		// tooltiprender event
		self._trigger('render');

		// Reset flags
		self.positioning = FALSE;

		// Show tooltip if not hidden during wait period
		if(!self.hiddenDuringWait && (options.show.ready || show)) {
			self.toggle(TRUE, cache.event, FALSE);
		}
		self.hiddenDuringWait = FALSE;
	});

	// Expose API
	QTIP.api[this.id] = this;

	return this;
};

PROTOTYPE.destroy = function(immediate) {
	// Set flag the signify destroy is taking place to plugins
	// and ensure it only gets destroyed once!
	if(this.destroyed) { return this.target; }

	function process() {
		if(this.destroyed) { return; }
		this.destroyed = TRUE;
		
		var target = this.target,
			title = target.attr(oldtitle);

		// Destroy tooltip if rendered
		if(this.rendered) {
			this.tooltip.stop(1,0).find('*').remove().end().remove();
		}

		// Destroy all plugins
		$.each(this.plugins, function(name) {
			this.destroy && this.destroy();
		});

		// Clear timers and remove bound events
		clearTimeout(this.timers.show);
		clearTimeout(this.timers.hide);
		this._unassignEvents();

		// Remove api object and ARIA attributes
		target.removeData(NAMESPACE)
			.removeAttr(ATTR_ID)
			.removeAttr(ATTR_HAS)
			.removeAttr('aria-describedby');

		// Reset old title attribute if removed
		if(this.options.suppress && title) {
			target.attr('title', title).removeAttr(oldtitle);
		}

		// Remove qTip events associated with this API
		this._unbind(target);

		// Remove ID from used id objects, and delete object references
		// for better garbage collection and leak protection
		this.options = this.elements = this.cache = this.timers = 
			this.plugins = this.mouse = NULL;

		// Delete epoxsed API object
		delete QTIP.api[this.id];
	}

	// If an immediate destory is needed
	if((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {
		this.tooltip.one('tooltiphidden', $.proxy(process, this));
		!this.triggering && this.hide();
	}

	// If we're not in the process of hiding... process
	else { process.call(this); }

	return this.target;
};

;function invalidOpt(a) {
	return a === NULL || $.type(a) !== 'object';
}

function invalidContent(c) {
	return !( $.isFunction(c) || (c && c.attr) || c.length || ($.type(c) === 'object' && (c.jquery || c.then) ));
}

// Option object sanitizer
function sanitizeOptions(opts) {
	var content, text, ajax, once;

	if(invalidOpt(opts)) { return FALSE; }

	if(invalidOpt(opts.metadata)) {
		opts.metadata = { type: opts.metadata };
	}

	if('content' in opts) {
		content = opts.content;

		if(invalidOpt(content) || content.jquery || content.done) {
			content = opts.content = {
				text: (text = invalidContent(content) ? FALSE : content)
			};
		}
		else { text = content.text; }

		// DEPRECATED - Old content.ajax plugin functionality
		// Converts it into the proper Deferred syntax
		if('ajax' in content) {
			ajax = content.ajax;
			once = ajax && ajax.once !== FALSE;
			delete content.ajax;

			content.text = function(event, api) {
				var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',

				deferred = $.ajax(
					$.extend({}, ajax, { context: api })
				)
				.then(ajax.success, NULL, ajax.error)
				.then(function(content) {
					if(content && once) { api.set('content.text', content); }
					return content;
				},
				function(xhr, status, error) {
					if(api.destroyed || xhr.status === 0) { return; }
					api.set('content.text', status + ': ' + error);
				});

				return !once ? (api.set('content.text', loading), deferred) : loading;
			};
		}

		if('title' in content) {
			if(!invalidOpt(content.title)) {
				content.button = content.title.button;
				content.title = content.title.text;
			}

			if(invalidContent(content.title || FALSE)) {
				content.title = FALSE;
			}
		}
	}

	if('position' in opts && invalidOpt(opts.position)) {
		opts.position = { my: opts.position, at: opts.position };
	}

	if('show' in opts && invalidOpt(opts.show)) {
		opts.show = opts.show.jquery ? { target: opts.show } : 
			opts.show === TRUE ? { ready: TRUE } : { event: opts.show };
	}

	if('hide' in opts && invalidOpt(opts.hide)) {
		opts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };
	}

	if('style' in opts && invalidOpt(opts.style)) {
		opts.style = { classes: opts.style };
	}

	// Sanitize plugin options
	$.each(PLUGINS, function() {
		this.sanitize && this.sanitize(opts);
	});

	return opts;
}

// Setup builtin .set() option checks
CHECKS = PROTOTYPE.checks = {
	builtin: {
		// Core checks
		'^id$': function(obj, o, v, prev) {
			var id = v === TRUE ? QTIP.nextid : v,
				new_id = NAMESPACE + '-' + id;

			if(id !== FALSE && id.length > 0 && !$('#'+new_id).length) {
				this._id = new_id;

				if(this.rendered) {
					this.tooltip[0].id = this._id;
					this.elements.content[0].id = this._id + '-content';
					this.elements.title[0].id = this._id + '-title';
				}
			}
			else { obj[o] = prev; }
		},
		'^prerender': function(obj, o, v) {
			v && !this.rendered && this.render(this.options.show.ready);
		},

		// Content checks
		'^content.text$': function(obj, o, v) {
			this._updateContent(v);
		},
		'^content.attr$': function(obj, o, v, prev) {
			if(this.options.content.text === this.target.attr(prev)) {
				this._updateContent( this.target.attr(v) );
			}
		},
		'^content.title$': function(obj, o, v) {

			// Remove title if content is null
			if(!v) { return this._removeTitle(); }

			// If title isn't already created, create it now and update
			v && !this.elements.title && this._createTitle();
			this._updateTitle(v);
		},
		'^content.button$': function(obj, o, v) {
			this._updateButton(v);
		},
		'^content.title.(text|button)$': function(obj, o, v) {
			this.set('content.'+o, v); // Backwards title.text/button compat
		}, 

		// Position checks
		'^position.(my|at)$': function(obj, o, v){
			'string' === typeof v && (obj[o] = new CORNER(v, o === 'at'));
		},
		'^position.container$': function(obj, o, v){
			this.rendered && this.tooltip.appendTo(v);
		},

		// Show checks
		'^show.ready$': function(obj, o, v) {
			v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
		},

		// Style checks
		'^style.classes$': function(obj, o, v, p) {
			this.rendered && this.tooltip.removeClass(p).addClass(v);
		},
		'^style.(width|height)': function(obj, o, v) {
			this.rendered && this.tooltip.css(o, v);
		},
		'^style.widget|content.title': function() {
			this.rendered && this._setWidget();
		},
		'^style.def': function(obj, o, v) {
			this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
		},

		// Events check
		'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {
			this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);
		},

		// Properties which require event reassignment
		'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {
			if(!this.rendered) { return; }

			// Set tracking flag
			var posOptions = this.options.position;
			this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);

			// Reassign events
			this._unassignEvents();
			this._assignEvents();
		}
	}
};

// Dot notation converter
function convertNotation(options, notation) {
	var i = 0, obj, option = options,

	// Split notation into array
	levels = notation.split('.');

	// Loop through
	while( option = option[ levels[i++] ] ) {
		if(i < levels.length) { obj = option; }
	}

	return [obj || options, levels.pop()];
}

PROTOTYPE.get = function(notation) {
	if(this.destroyed) { return this; }

	var o = convertNotation(this.options, notation.toLowerCase()),
		result = o[0][ o[1] ];

	return result.precedance ? result.string() : result;
};

function setCallback(notation, args) {
	var category, rule, match;

	for(category in this.checks) {
		for(rule in this.checks[category]) {
			if(match = (new RegExp(rule, 'i')).exec(notation)) {
				args.push(match);

				if(category === 'builtin' || this.plugins[category]) {
					this.checks[category][rule].apply(
						this.plugins[category] || this, args
					);
				}
			}
		}
	}
}

var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i,
	rrender = /^prerender|show\.ready/i;

PROTOTYPE.set = function(option, value) {
	if(this.destroyed) { return this; }

	var rendered = this.rendered,
		reposition = FALSE,
		options = this.options,
		checks = this.checks,
		name;

	// Convert singular option/value pair into object form
	if('string' === typeof option) {
		name = option; option = {}; option[name] = value;
	}
	else { option = $.extend({}, option); }

	// Set all of the defined options to their new values
	$.each(option, function(notation, value) {
		if(rendered && rrender.test(notation)) {
			delete option[notation]; return;
		}

		// Set new obj value
		var obj = convertNotation(options, notation.toLowerCase()), previous;
		previous = obj[0][ obj[1] ];
		obj[0][ obj[1] ] = value && value.nodeType ? $(value) : value;

		// Also check if we need to reposition
		reposition = rmove.test(notation) || reposition;

		// Set the new params for the callback
		option[notation] = [obj[0], obj[1], value, previous];
	});

	// Re-sanitize options
	sanitizeOptions(options);

	/*
	 * Execute any valid callbacks for the set options
	 * Also set positioning flag so we don't get loads of redundant repositioning calls.
	 */
	this.positioning = TRUE;
	$.each(option, $.proxy(setCallback, this));
	this.positioning = FALSE;

	// Update position if needed
	if(this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
		this.reposition( options.position.target === 'mouse' ? NULL : this.cache.event );
	}

	return this;
};

;PROTOTYPE._update = function(content, element, reposition) {
	var self = this,
		cache = this.cache;

	// Make sure tooltip is rendered and content is defined. If not return
	if(!this.rendered || !content) { return FALSE; }

	// Use function to parse content
	if($.isFunction(content)) {
		content = content.call(this.elements.target, cache.event, this) || '';
	}

	// Handle deferred content
	if($.isFunction(content.then)) {
		cache.waiting = TRUE;
		return content.then(function(c) {
			cache.waiting = FALSE;
			return self._update(c, element);
		}, NULL, function(e) {
			return self._update(e, element);
		});
	}

	// If content is null... return false
	if(content === FALSE || (!content && content !== '')) { return FALSE; }

	// Append new content if its a DOM array and show it if hidden
	if(content.jquery && content.length > 0) {
		element.empty().append(
			content.css({ display: 'block', visibility: 'visible' })
		);
	}

	// Content is a regular string, insert the new content
	else { element.html(content); }

	// Wait for content to be loaded, and reposition
	return this._waitForContent(element).then(function(images) {
		if(images.images && images.images.length && self.rendered && self.tooltip[0].offsetWidth > 0) {
			self.reposition(cache.event, !images.length);
		}
	});
};

PROTOTYPE._waitForContent = function(element) {
	var cache = this.cache;
	
	// Set flag
	cache.waiting = TRUE;

	// If imagesLoaded is included, ensure images have loaded and return promise
	return ( $.fn.imagesLoaded ? element.imagesLoaded() : $.Deferred().resolve([]) )
		.done(function() { cache.waiting = FALSE; })
		.promise();
};

PROTOTYPE._updateContent = function(content, reposition) {
	this._update(content, this.elements.content, reposition);
};

PROTOTYPE._updateTitle = function(content, reposition) {
	if(this._update(content, this.elements.title, reposition) === FALSE) {
		this._removeTitle(FALSE);
	}
};

PROTOTYPE._createTitle = function()
{
	var elements = this.elements,
		id = this._id+'-title';

	// Destroy previous title element, if present
	if(elements.titlebar) { this._removeTitle(); }

	// Create title bar and title elements
	elements.titlebar = $('<div />', {
		'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')
	})
	.append(
		elements.title = $('<div />', {
			'id': id,
			'class': NAMESPACE + '-title',
			'aria-atomic': TRUE
		})
	)
	.insertBefore(elements.content)

	// Button-specific events
	.delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {
		$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');
	})
	.delegate('.qtip-close', 'mouseover mouseout', function(event){
		$(this).toggleClass('ui-state-hover', event.type === 'mouseover');
	});

	// Create button if enabled
	if(this.options.content.button) { this._createButton(); }
};

PROTOTYPE._removeTitle = function(reposition)
{
	var elements = this.elements;

	if(elements.title) {
		elements.titlebar.remove();
		elements.titlebar = elements.title = elements.button = NULL;

		// Reposition if enabled
		if(reposition !== FALSE) { this.reposition(); }
	}
};

;PROTOTYPE.reposition = function(event, effect) {
	if(!this.rendered || this.positioning || this.destroyed) { return this; }

	// Set positioning flag
	this.positioning = TRUE;

	var cache = this.cache,
		tooltip = this.tooltip,
		posOptions = this.options.position,
		target = posOptions.target,
		my = posOptions.my,
		at = posOptions.at,
		viewport = posOptions.viewport,
		container = posOptions.container,
		adjust = posOptions.adjust,
		method = adjust.method.split(' '),
		tooltipWidth = tooltip.outerWidth(FALSE),
		tooltipHeight = tooltip.outerHeight(FALSE),
		targetWidth = 0,
		targetHeight = 0,
		type = tooltip.css('position'),
		position = { left: 0, top: 0 },
		visible = tooltip[0].offsetWidth > 0,
		isScroll = event && event.type === 'scroll',
		win = $(window),
		doc = container[0].ownerDocument,
		mouse = this.mouse,
		pluginCalculations, offset;

	// Check if absolute position was passed
	if($.isArray(target) && target.length === 2) {
		// Force left top and set position
		at = { x: LEFT, y: TOP };
		position = { left: target[0], top: target[1] };
	}

	// Check if mouse was the target
	else if(target === 'mouse') {
		// Force left top to allow flipping
		at = { x: LEFT, y: TOP };

		// Use the cached mouse coordinates if available, or passed event has no coordinates
		if(mouse && mouse.pageX && (adjust.mouse || !event || !event.pageX) ) {
			event = mouse;
		}
		
		// If the passed event has no coordinates (such as a scroll event)
		else if(!event || !event.pageX) {
			// Use the mouse origin that caused the show event, if distance hiding is enabled
			if((!adjust.mouse || this.options.show.distance) && cache.origin && cache.origin.pageX) {
				event =  cache.origin;
			}

			// Use cached event for resize/scroll events
			else if(!event || (event && (event.type === 'resize' || event.type === 'scroll'))) {
				event = cache.event;
			}
		}

		// Calculate body and container offset and take them into account below
		if(type !== 'static') { position = container.offset(); }
		if(doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {
			offset = $(document.body).offset();
		}

		// Use event coordinates for position
		position = {
			left: event.pageX - position.left + (offset && offset.left || 0),
			top: event.pageY - position.top + (offset && offset.top || 0)
		};

		// Scroll events are a pain, some browsers
		if(adjust.mouse && isScroll && mouse) {
			position.left -= (mouse.scrollX || 0) - win.scrollLeft();
			position.top -= (mouse.scrollY || 0) - win.scrollTop();
		}
	}

	// Target wasn't mouse or absolute...
	else {
		// Check if event targetting is being used
		if(target === 'event') {
			if(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {
				cache.target = $(event.target);
			}
			else if(!event.target) {
				cache.target = this.elements.target;
			}
		}
		else if(target !== 'event'){
			cache.target = $(target.jquery ? target : this.elements.target);
		}
		target = cache.target;

		// Parse the target into a jQuery object and make sure there's an element present
		target = $(target).eq(0);
		if(target.length === 0) { return this; }

		// Check if window or document is the target
		else if(target[0] === document || target[0] === window) {
			targetWidth = BROWSER.iOS ? window.innerWidth : target.width();
			targetHeight = BROWSER.iOS ? window.innerHeight : target.height();

			if(target[0] === window) {
				position = {
					top: (viewport || target).scrollTop(),
					left: (viewport || target).scrollLeft()
				};
			}
		}

		// Check if the target is an <AREA> element
		else if(PLUGINS.imagemap && target.is('area')) {
			pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
		}

		// Check if the target is an SVG element
		else if(PLUGINS.svg && target && target[0].ownerSVGElement) {
			pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
		}

		// Otherwise use regular jQuery methods
		else {
			targetWidth = target.outerWidth(FALSE);
			targetHeight = target.outerHeight(FALSE);
			position = target.offset();
		}

		// Parse returned plugin values into proper variables
		if(pluginCalculations) {
			targetWidth = pluginCalculations.width;
			targetHeight = pluginCalculations.height;
			offset = pluginCalculations.offset;
			position = pluginCalculations.position;
		}

		// Adjust position to take into account offset parents
		position = this.reposition.offset(target, position, container);

		// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)
		if((BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1) || 
			(BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33) || 
			(!BROWSER.iOS && type === 'fixed')
		){
			position.left -= win.scrollLeft();
			position.top -= win.scrollTop();
		}

		// Adjust position relative to target
		if(!pluginCalculations || (pluginCalculations && pluginCalculations.adjustable !== FALSE)) {
			position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
			position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
		}
	}

	// Adjust position relative to tooltip
	position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
	position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);

	// Use viewport adjustment plugin if enabled
	if(PLUGINS.viewport) {
		position.adjusted = PLUGINS.viewport(
			this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight
		);

		// Apply offsets supplied by positioning plugin (if used)
		if(offset && position.adjusted.left) { position.left += offset.left; }
		if(offset && position.adjusted.top) {  position.top += offset.top; }
	}

	// Viewport adjustment is disabled, set values to zero
	else { position.adjusted = { left: 0, top: 0 }; }

	// tooltipmove event
	if(!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }
	delete position.adjusted;

	// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly
	if(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {
		tooltip.css(position);
	}

	// Use custom function if provided
	else if($.isFunction(posOptions.effect)) {
		posOptions.effect.call(tooltip, this, $.extend({}, position));
		tooltip.queue(function(next) {
			// Reset attributes to avoid cross-browser rendering bugs
			$(this).css({ opacity: '', height: '' });
			if(BROWSER.ie) { this.style.removeAttribute('filter'); }

			next();
		});
	}

	// Set positioning flag
	this.positioning = FALSE;

	return this;
};

// Custom (more correct for qTip!) offset calculator
PROTOTYPE.reposition.offset = function(elem, pos, container) {
	if(!container[0]) { return pos; }

	var ownerDocument = $(elem[0].ownerDocument),
		quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',
		parent = container[0],
		scrolled, position, parentOffset, overflow;

	function scroll(e, i) {
		pos.left += i * e.scrollLeft();
		pos.top += i * e.scrollTop();
	}

	// Compensate for non-static containers offset
	do {
		if((position = $.css(parent, 'position')) !== 'static') {
			if(position === 'fixed') {
				parentOffset = parent.getBoundingClientRect();
				scroll(ownerDocument, -1);
			}
			else {
				parentOffset = $(parent).position();
				parentOffset.left += (parseFloat($.css(parent, 'borderLeftWidth')) || 0);
				parentOffset.top += (parseFloat($.css(parent, 'borderTopWidth')) || 0);
			}

			pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);
			pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);

			// If this is the first parent element with an overflow of "scroll" or "auto", store it
			if(!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }
		}
	}
	while((parent = parent.offsetParent));

	// Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)
	if(scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
		scroll(scrolled, 1);
	}

	return pos;
};

// Corner class
var C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {
	corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();
	this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();
	this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();
	this.forceY = !!forceY;

	var f = corner.charAt(0);
	this.precedance = (f === 't' || f === 'b' ? Y : X);
}).prototype;

C.invert = function(z, center) {
	this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];	
};

C.string = function() {
	var x = this.x, y = this.y;
	return x === y ? x : this.precedance === Y || (this.forceY && y !== 'center') ? y+' '+x : x+' '+y;
};

C.abbrev = function() {
	var result = this.string().split(' ');
	return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');
};

C.clone = function() {
	return new CORNER( this.string(), this.forceY );
};;
PROTOTYPE.toggle = function(state, event) {
	var cache = this.cache,
		options = this.options,
		tooltip = this.tooltip;

	// Try to prevent flickering when tooltip overlaps show element
	if(event) {
		if((/over|enter/).test(event.type) && (/out|leave/).test(cache.event.type) &&
			options.show.target.add(event.target).length === options.show.target.length &&
			tooltip.has(event.relatedTarget).length) {
			return this;
		}

		// Cache event
		cache.event = cloneEvent(event);
	}
		
	// If we're currently waiting and we've just hidden... stop it
	this.waiting && !state && (this.hiddenDuringWait = TRUE);

	// Render the tooltip if showing and it isn't already
	if(!this.rendered) { return state ? this.render(1) : this; }
	else if(this.destroyed || this.disabled) { return this; }

	var type = state ? 'show' : 'hide',
		opts = this.options[type],
		otherOpts = this.options[ !state ? 'show' : 'hide' ],
		posOptions = this.options.position,
		contentOptions = this.options.content,
		width = this.tooltip.css('width'),
		visible = this.tooltip.is(':visible'),
		animate = state || opts.target.length === 1,
		sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,
		identicalState, allow, showEvent, delay, after;

	// Detect state if valid one isn't provided
	if((typeof state).search('boolean|number')) { state = !visible; }

	// Check if the tooltip is in an identical state to the new would-be state
	identicalState = !tooltip.is(':animated') && visible === state && sameTarget;

	// Fire tooltip(show/hide) event and check if destroyed
	allow = !identicalState ? !!this._trigger(type, [90]) : NULL;

	// Check to make sure the tooltip wasn't destroyed in the callback
	if(this.destroyed) { return this; }

	// If the user didn't stop the method prematurely and we're showing the tooltip, focus it
	if(allow !== FALSE && state) { this.focus(event); }

	// If the state hasn't changed or the user stopped it, return early
	if(!allow || identicalState) { return this; }

	// Set ARIA hidden attribute
	$.attr(tooltip[0], 'aria-hidden', !!!state);

	// Execute state specific properties
	if(state) {
		// Store show origin coordinates
		cache.origin = cloneEvent(this.mouse);

		// Update tooltip content & title if it's a dynamic function
		if($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }
		if($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }

		// Cache mousemove events for positioning purposes (if not already tracking)
		if(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {
			$(document).bind('mousemove.'+NAMESPACE, this._storeMouse);
			trackingBound = TRUE;
		}

		// Update the tooltip position (set width first to prevent viewport/max-width issues)
		if(!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }
		this.reposition(event, arguments[2]);
		if(!width) { tooltip.css('width', ''); }

		// Hide other tooltips if tooltip is solo
		if(!!opts.solo) {
			(typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))
				.not(tooltip).not(opts.target).qtip('hide', $.Event('tooltipsolo'));
		}
	}
	else {
		// Clear show timer if we're hiding
		clearTimeout(this.timers.show);

		// Remove cached origin on hide
		delete cache.origin;

		// Remove mouse tracking event if not needed (all tracking qTips are hidden)
		if(trackingBound && !$(SELECTOR+'[tracking="true"]:visible', opts.solo).not(tooltip).length) {
			$(document).unbind('mousemove.'+NAMESPACE);
			trackingBound = FALSE;
		}

		// Blur the tooltip
		this.blur(event);
	}

	// Define post-animation, state specific properties
	after = $.proxy(function() {
		if(state) {
			// Prevent antialias from disappearing in IE by removing filter
			if(BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }

			// Remove overflow setting to prevent tip bugs
			tooltip.css('overflow', '');

			// Autofocus elements if enabled
			if('string' === typeof opts.autofocus) {
				$(this.options.show.autofocus, tooltip).focus();
			}

			// If set, hide tooltip when inactive for delay period
			this.options.show.target.trigger('qtip-'+this.id+'-inactive');
		}
		else {
			// Reset CSS states
			tooltip.css({
				display: '',
				visibility: '',
				opacity: '',
				left: '',
				top: ''
			});
		}

		// tooltipvisible/tooltiphidden events
		this._trigger(state ? 'visible' : 'hidden');
	}, this);

	// If no effect type is supplied, use a simple toggle
	if(opts.effect === FALSE || animate === FALSE) {
		tooltip[ type ]();
		after();
	}

	// Use custom function if provided
	else if($.isFunction(opts.effect)) {
		tooltip.stop(1, 1);
		opts.effect.call(tooltip, this);
		tooltip.queue('fx', function(n) {
			after(); n();
		});
	}

	// Use basic fade function by default
	else { tooltip.fadeTo(90, state ? 1 : 0, after); }

	// If inactive hide method is set, active it
	if(state) { opts.target.trigger('qtip-'+this.id+'-inactive'); }

	return this;
};

PROTOTYPE.show = function(event) { return this.toggle(TRUE, event); };

PROTOTYPE.hide = function(event) { return this.toggle(FALSE, event); };

;PROTOTYPE.focus = function(event) {
	if(!this.rendered || this.destroyed) { return this; }

	var qtips = $(SELECTOR),
		tooltip = this.tooltip,
		curIndex = parseInt(tooltip[0].style.zIndex, 10),
		newIndex = QTIP.zindex + qtips.length,
		focusedElem;

	// Only update the z-index if it has changed and tooltip is not already focused
	if(!tooltip.hasClass(CLASS_FOCUS)) {
		// tooltipfocus event
		if(this._trigger('focus', [newIndex], event)) {
			// Only update z-index's if they've changed
			if(curIndex !== newIndex) {
				// Reduce our z-index's and keep them properly ordered
				qtips.each(function() {
					if(this.style.zIndex > curIndex) {
						this.style.zIndex = this.style.zIndex - 1;
					}
				});

				// Fire blur event for focused tooltip
				qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);
			}

			// Set the new z-index
			tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
		}
	}

	return this;
};

PROTOTYPE.blur = function(event) {
	if(!this.rendered || this.destroyed) { return this; }

	// Set focused status to FALSE
	this.tooltip.removeClass(CLASS_FOCUS);

	// tooltipblur event
	this._trigger('blur', [ this.tooltip.css('zIndex') ], event);

	return this;
};

;PROTOTYPE.disable = function(state) {
	if(this.destroyed) { return this; }

	// If 'toggle' is passed, toggle the current state
	if(state === 'toggle') {
		state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
	}

	// Disable if no state passed
	else if('boolean' !== typeof state) {
		state = TRUE;
	}

	if(this.rendered) {
		this.tooltip.toggleClass(CLASS_DISABLED, state)
			.attr('aria-disabled', state);
	}

	this.disabled = !!state;

	return this;
};

PROTOTYPE.enable = function() { return this.disable(FALSE); };

;PROTOTYPE._createButton = function()
{
	var self = this,
		elements = this.elements,
		tooltip = elements.tooltip,
		button = this.options.content.button,
		isString = typeof button === 'string',
		close = isString ? button : 'Close tooltip';

	if(elements.button) { elements.button.remove(); }

	// Use custom button if one was supplied by user, else use default
	if(button.jquery) {
		elements.button = button;
	}
	else {
		elements.button = $('<a />', {
			'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE+'-icon'),
			'title': close,
			'aria-label': close
		})
		.prepend(
			$('<span />', {
				'class': 'ui-icon ui-icon-close',
				'html': '&times;'
			})
		);
	}

	// Create button and setup attributes
	elements.button.appendTo(elements.titlebar || tooltip)
		.attr('role', 'button')
		.click(function(event) {
			if(!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }
			return FALSE;
		});
};

PROTOTYPE._updateButton = function(button)
{
	// Make sure tooltip is rendered and if not, return
	if(!this.rendered) { return FALSE; }

	var elem = this.elements.button;
	if(button) { this._createButton(); }
	else { elem.remove(); }
};

;// Widget class creator
function createWidgetClass(cls) {
	return WIDGET.concat('').join(cls ? '-'+cls+' ' : ' ');
}

// Widget class setter method
PROTOTYPE._setWidget = function()
{
	var on = this.options.style.widget,
		elements = this.elements,
		tooltip = elements.tooltip,
		disabled = tooltip.hasClass(CLASS_DISABLED);

	tooltip.removeClass(CLASS_DISABLED);
	CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';
	tooltip.toggleClass(CLASS_DISABLED, disabled);

	tooltip.toggleClass('ui-helper-reset '+createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);
	
	if(elements.content) {
		elements.content.toggleClass( createWidgetClass('content'), on);
	}
	if(elements.titlebar) {
		elements.titlebar.toggleClass( createWidgetClass('header'), on);
	}
	if(elements.button) {
		elements.button.toggleClass(NAMESPACE+'-icon', !on);
	}
};;function cloneEvent(event) {
	return event && {
		type: event.type,
		pageX: event.pageX,
		pageY: event.pageY,
		target: event.target,
		relatedTarget: event.relatedTarget,
		scrollX: event.scrollX || window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft,
		scrollY: event.scrollY || window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop
	} || {};
}

function delay(callback, duration) {
	// If tooltip has displayed, start hide timer
	if(duration > 0) {
		return setTimeout(
			$.proxy(callback, this), duration
		);
	}
	else{ callback.call(this); }
}

function showMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }

	// Clear hide timers
	clearTimeout(this.timers.show);
	clearTimeout(this.timers.hide);

	// Start show timer
	this.timers.show = delay.call(this,
		function() { this.toggle(TRUE, event); },
		this.options.show.delay
	);
}

function hideMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED)) { return FALSE; }

	// Check if new target was actually the tooltip element
	var relatedTarget = $(event.relatedTarget),
		ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],
		ontoTarget = relatedTarget[0] === this.options.show.target[0];

	// Clear timers and stop animation queue
	clearTimeout(this.timers.show);
	clearTimeout(this.timers.hide);

	// Prevent hiding if tooltip is fixed and event target is the tooltip.
	// Or if mouse positioning is enabled and cursor momentarily overlaps
	if(this !== relatedTarget[0] && 
		(this.options.position.target === 'mouse' && ontoTooltip) || 
		(this.options.hide.fixed && (
			(/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))
		))
	{
		try {
			event.preventDefault();
			event.stopImmediatePropagation();
		} catch(e) {}

		return;
	}

	// If tooltip has displayed, start hide timer
	this.timers.hide = delay.call(this,
		function() { this.toggle(FALSE, event); },
		this.options.hide.delay,
		this
	);
}

function inactiveMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return FALSE; }

	// Clear timer
	clearTimeout(this.timers.inactive);

	this.timers.inactive = delay.call(this,
		function(){ this.hide(event); },
		this.options.hide.inactive
	);
}

function repositionMethod(event) {
	if(this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }
}

// Store mouse coordinates
PROTOTYPE._storeMouse = function(event) {
	(this.mouse = cloneEvent(event)).type = 'mousemove';
};

// Bind events
PROTOTYPE._bind = function(targets, events, method, suffix, context) {
	var ns = '.' + this._id + (suffix ? '-'+suffix : '');
	events.length && $(targets).bind(
		(events.split ? events : events.join(ns + ' ')) + ns,
		$.proxy(method, context || this)
	);
};
PROTOTYPE._unbind = function(targets, suffix) {
	$(targets).unbind('.' + this._id + (suffix ? '-'+suffix : ''));
};

// Apply common event handlers using delegate (avoids excessive .bind calls!)
var ns = '.'+NAMESPACE;
function delegate(selector, events, method) {	
	$(document.body).delegate(selector,
		(events.split ? events : events.join(ns + ' ')) + ns,
		function() {
			var api = QTIP.api[ $.attr(this, ATTR_ID) ];
			api && !api.disabled && method.apply(api, arguments);
		}
	);
}

$(function() {
	delegate(SELECTOR, ['mouseenter', 'mouseleave'], function(event) {
		var state = event.type === 'mouseenter',
			tooltip = $(event.currentTarget),
			target = $(event.relatedTarget || event.target),
			options = this.options;

		// On mouseenter...
		if(state) {
			// Focus the tooltip on mouseenter (z-index stacking)
			this.focus(event);

			// Clear hide timer on tooltip hover to prevent it from closing
			tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
		}

		// On mouseleave...
		else {
			// Hide when we leave the tooltip and not onto the show target (if a hide event is set)
			if(options.position.target === 'mouse' && options.hide.event && 
				options.show.target && !target.closest(options.show.target[0]).length) {
				this.hide(event);
			}
		}

		// Add hover class
		tooltip.toggleClass(CLASS_HOVER, state);
	});

	// Define events which reset the 'inactive' event handler
	delegate('['+ATTR_ID+']', INACTIVE_EVENTS, inactiveMethod);
});

// Event trigger
PROTOTYPE._trigger = function(type, args, event) {
	var callback = $.Event('tooltip'+type);
	callback.originalEvent = (event && $.extend({}, event)) || this.cache.event || NULL;

	this.triggering = type;
	this.tooltip.trigger(callback, [this].concat(args || []));
	this.triggering = FALSE;

	return !callback.isDefaultPrevented();
};

PROTOTYPE._bindEvents = function(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod) {
	// If hide and show targets are the same...
	if(hideTarget.add(showTarget).length === hideTarget.length) {
		var toggleEvents = [];

		// Filter identical show/hide events
		hideEvents = $.map(hideEvents, function(type) {
			var showIndex = $.inArray(type, showEvents);

			// Both events are identical, remove from both hide and show events
			// and append to toggleEvents
			if(showIndex > -1) {
				toggleEvents.push( showEvents.splice( showIndex, 1 )[0] );
				return;
			}

			return type;
		});

		// Toggle events are special case of identical show/hide events, which happen in sequence
		toggleEvents.length && this._bind(showTarget, toggleEvents, function(event) {
			var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
			(state ? hideMethod : showMethod).call(this, event);
		});
	}

	// Apply show/hide/toggle events
	this._bind(showTarget, showEvents, showMethod);
	this._bind(hideTarget, hideEvents, hideMethod);
};

PROTOTYPE._assignInitialEvents = function(event) {
	var options = this.options,
		showTarget = options.show.target,
		hideTarget = options.hide.target,
		showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
		hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];

	/*
	 * Make sure hoverIntent functions properly by using mouseleave as a hide event if
	 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
	 */
	if(/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {
		hideEvents.push('mouseleave');
	}

	/*
	 * Also make sure initial mouse targetting works correctly by caching mousemove coords
	 * on show targets before the tooltip has rendered. Also set onTarget when triggered to
	 * keep mouse tracking working.
	 */
	this._bind(showTarget, 'mousemove', function(event) {
		this._storeMouse(event);
		this.cache.onTarget = TRUE;
	});

	// Define hoverIntent function
	function hoverIntent(event) {
		// Only continue if tooltip isn't disabled
		if(this.disabled || this.destroyed) { return FALSE; }

		// Cache the event data
		this.cache.event = cloneEvent(event);
		this.cache.target = event ? $(event.target) : [undefined];

		// Start the event sequence
		clearTimeout(this.timers.show);
		this.timers.show = delay.call(this,
			function() { this.render(typeof event === 'object' || options.show.ready); },
			options.show.delay
		);
	}

	// Filter and bind events
	this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {
		clearTimeout(this.timers.show);
	});

	// Prerendering is enabled, create tooltip now
	if(options.show.ready || options.prerender) { hoverIntent.call(this, event); }
};

// Event assignment method
PROTOTYPE._assignEvents = function() {
	var self = this,
		options = this.options,
		posOptions = options.position,

		tooltip = this.tooltip,
		showTarget = options.show.target,
		hideTarget = options.hide.target,
		containerTarget = posOptions.container,
		viewportTarget = posOptions.viewport,
		documentTarget = $(document),
		bodyTarget = $(document.body),
		windowTarget = $(window),

		showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
		hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];


	// Assign passed event callbacks
	$.each(options.events, function(name, callback) {
		self._bind(tooltip, name === 'toggle' ? ['tooltipshow','tooltiphide'] : ['tooltip'+name], callback, null, tooltip);
	});

	// Hide tooltips when leaving current window/frame (but not select/option elements)
	if(/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {
		this._bind(documentTarget, ['mouseout', 'blur'], function(event) {
			if(!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
				this.hide(event);
			}
		});
	}

	// Enable hide.fixed by adding appropriate class
	if(options.hide.fixed) {
		hideTarget = hideTarget.add( tooltip.addClass(CLASS_FIXED) );
	}

	/*
	 * Make sure hoverIntent functions properly by using mouseleave to clear show timer if
	 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
	 */
	else if(/mouse(over|enter)/i.test(options.show.event)) {
		this._bind(hideTarget, 'mouseleave', function() {
			clearTimeout(this.timers.show);
		});
	}

	// Hide tooltip on document mousedown if unfocus events are enabled
	if(('' + options.hide.event).indexOf('unfocus') > -1) {
		this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function(event) {
			var elem = $(event.target),
				enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,
				isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;

			if(elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&
				!this.target.has(elem[0]).length && enabled
			) {
				this.hide(event);
			}
		});
	}

	// Check if the tooltip hides when inactive
	if('number' === typeof options.hide.inactive) {
		// Bind inactive method to show target(s) as a custom event
		this._bind(showTarget, 'qtip-'+this.id+'-inactive', inactiveMethod);

		// Define events which reset the 'inactive' event handler
		this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod, '-inactive');
	}

	// Filter and bind events
	this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);

	// Mouse movement bindings
	this._bind(showTarget.add(tooltip), 'mousemove', function(event) {
		// Check if the tooltip hides when mouse is moved a certain distance
		if('number' === typeof options.hide.distance) {
			var origin = this.cache.origin || {},
				limit = this.options.hide.distance,
				abs = Math.abs;

			// Check if the movement has gone beyond the limit, and hide it if so
			if(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
				this.hide(event);
			}
		}

		// Cache mousemove coords on show targets
		this._storeMouse(event);
	});

	// Mouse positioning events
	if(posOptions.target === 'mouse') {
		// If mouse adjustment is on...
		if(posOptions.adjust.mouse) {
			// Apply a mouseleave event so we don't get problems with overlapping
			if(options.hide.event) {
				// Track if we're on the target or not
				this._bind(showTarget, ['mouseenter', 'mouseleave'], function(event) {
					this.cache.onTarget = event.type === 'mouseenter';
				});
			}

			// Update tooltip position on mousemove
			this._bind(documentTarget, 'mousemove', function(event) {
				// Update the tooltip position only if the tooltip is visible and adjustment is enabled
				if(this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
					this.reposition(event);
				}
			});
		}
	}

	// Adjust positions of the tooltip on window resize if enabled
	if(posOptions.adjust.resize || viewportTarget.length) {
		this._bind( $.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod );
	}

	// Adjust tooltip position on scroll of the window or viewport element if present
	if(posOptions.adjust.scroll) {
		this._bind( windowTarget.add(posOptions.container), 'scroll', repositionMethod );
	}
};

// Un-assignment method
PROTOTYPE._unassignEvents = function() {
	var targets = [
		this.options.show.target[0],
		this.options.hide.target[0],
		this.rendered && this.tooltip[0],
		this.options.position.container[0],
		this.options.position.viewport[0],
		this.options.position.container.closest('html')[0], // unfocus
		window,
		document
	];

	this._unbind($([]).pushStack( $.grep(targets, function(i) {
		return typeof i === 'object';
	})));
};

;// Initialization method
function init(elem, id, opts) {
	var obj, posOptions, attr, config, title,

	// Setup element references
	docBody = $(document.body),

	// Use document body instead of document element if needed
	newTarget = elem[0] === document ? docBody : elem,

	// Grab metadata from element if plugin is present
	metadata = (elem.metadata) ? elem.metadata(opts.metadata) : NULL,

	// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise
	metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,

	// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,
	html5 = elem.data(opts.metadata.name || 'qtipopts');

	// If we don't get an object returned attempt to parse it manualyl without parseJSON
	try { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; } catch(e) {}

	// Merge in and sanitize metadata
	config = $.extend(TRUE, {}, QTIP.defaults, opts,
		typeof html5 === 'object' ? sanitizeOptions(html5) : NULL,
		sanitizeOptions(metadata5 || metadata));

	// Re-grab our positioning options now we've merged our metadata and set id to passed value
	posOptions = config.position;
	config.id = id;

	// Setup missing content if none is detected
	if('boolean' === typeof config.content.text) {
		attr = elem.attr(config.content.attr);

		// Grab from supplied attribute if available
		if(config.content.attr !== FALSE && attr) { config.content.text = attr; }

		// No valid content was found, abort render
		else { return FALSE; }
	}

	// Setup target options
	if(!posOptions.container.length) { posOptions.container = docBody; }
	if(posOptions.target === FALSE) { posOptions.target = newTarget; }
	if(config.show.target === FALSE) { config.show.target = newTarget; }
	if(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }
	if(config.hide.target === FALSE) { config.hide.target = newTarget; }
	if(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }

	// Ensure we only use a single container
	posOptions.container = posOptions.container.eq(0);

	// Convert position corner values into x and y strings
	posOptions.at = new CORNER(posOptions.at, TRUE);
	posOptions.my = new CORNER(posOptions.my);

	// Destroy previous tooltip if overwrite is enabled, or skip element if not
	if(elem.data(NAMESPACE)) {
		if(config.overwrite) {
			elem.qtip('destroy', true);
		}
		else if(config.overwrite === FALSE) {
			return FALSE;
		}
	}

	// Add has-qtip attribute
	elem.attr(ATTR_HAS, id);

	// Remove title attribute and store it if present
	if(config.suppress && (title = elem.attr('title'))) {
		// Final attr call fixes event delegatiom and IE default tooltip showing problem
		elem.removeAttr('title').attr(oldtitle, title).attr('title', '');
	}

	// Initialize the tooltip and add API reference
	obj = new QTip(elem, config, id, !!attr);
	elem.data(NAMESPACE, obj);

	// Catch remove/removeqtip events on target element to destroy redundant tooltip
	elem.one('remove.qtip-'+id+' removeqtip.qtip-'+id, function() { 
		var api; if((api = $(this).data(NAMESPACE))) { api.destroy(true); }
	});

	return obj;
}

// jQuery $.fn extension method
QTIP = $.fn.qtip = function(options, notation, newValue)
{
	var command = ('' + options).toLowerCase(), // Parse command
		returned = NULL,
		args = $.makeArray(arguments).slice(1),
		event = args[args.length - 1],
		opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;

	// Check for API request
	if((!arguments.length && opts) || command === 'api') {
		return opts;
	}

	// Execute API command if present
	else if('string' === typeof options) {
		this.each(function() {
			var api = $.data(this, NAMESPACE);
			if(!api) { return TRUE; }

			// Cache the event if possible
			if(event && event.timeStamp) { api.cache.event = event; }

			// Check for specific API commands
			if(notation && (command === 'option' || command === 'options')) {
				if(newValue !== undefined || $.isPlainObject(notation)) {
					api.set(notation, newValue);
				}
				else {
					returned = api.get(notation);
					return FALSE;
				}
			}

			// Execute API command
			else if(api[command]) {
				api[command].apply(api, args);
			}
		});

		return returned !== NULL ? returned : this;
	}

	// No API commands. validate provided options and setup qTips
	else if('object' === typeof options || !arguments.length) {
		// Sanitize options first
		opts = sanitizeOptions($.extend(TRUE, {}, options));

		return this.each(function(i) {
			var api, id;

			// Find next available ID, or use custom ID if provided
			id = $.isArray(opts.id) ? opts.id[i] : opts.id;
			id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;

			// Initialize the qTip and re-grab newly sanitized options
			api = init($(this), id, opts);
			if(api === FALSE) { return TRUE; }
			else { QTIP.api[id] = api; }

			// Initialize plugins
			$.each(PLUGINS, function() {
				if(this.initialize === 'initialize') { this(api); }
			});

			// Assign initial pre-render events
			api._assignInitialEvents(event);
		});
	}
};

// Expose class
$.qtip = QTip;

// Populated in render method
QTIP.api = {};
;$.each({
	/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
	attr: function(attr, val) {
		if(this.length) {
			var self = this[0],
				title = 'title',
				api = $.data(self, 'qtip');

			if(attr === title && api && 'object' === typeof api && api.options.suppress) {
				if(arguments.length < 2) {
					return $.attr(self, oldtitle);
				}

				// If qTip is rendered and title was originally used as content, update it
				if(api && api.options.content.attr === title && api.cache.attr) {
					api.set('content.text', val);
				}

				// Use the regular attr method to set, then cache the result
				return this.attr(oldtitle, val);
			}
		}

		return $.fn['attr'+replaceSuffix].apply(this, arguments);
	},

	/* Allow clone to correctly retrieve cached title attributes */
	clone: function(keepData) {
		var titles = $([]), title = 'title',

		// Clone our element using the real clone method
		elems = $.fn['clone'+replaceSuffix].apply(this, arguments);

		// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false
		if(!keepData) {
			elems.filter('['+oldtitle+']').attr('title', function() {
				return $.attr(this, oldtitle);
			})
			.removeAttr(oldtitle);
		}

		return elems;
	}
}, function(name, func) {
	if(!func || $.fn[name+replaceSuffix]) { return TRUE; }

	var old = $.fn[name+replaceSuffix] = $.fn[name];
	$.fn[name] = function() {
		return func.apply(this, arguments) || old.apply(this, arguments);
	};
});

/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).
 * This snippet is taken directly from jQuery UI source code found here:
 *     http://code.jquery.com/ui/jquery-ui-git.js
 */
if(!$.ui) {
	$['cleanData'+replaceSuffix] = $.cleanData;
	$.cleanData = function( elems ) {
		for(var i = 0, elem; (elem = $( elems[i] )).length; i++) {
			if(elem.attr(ATTR_HAS)) {
				try { elem.triggerHandler('removeqtip'); } 
				catch( e ) {}
			}
		}
		$['cleanData'+replaceSuffix].apply(this, arguments);
	};
}

;// qTip version
QTIP.version = '2.2.0';

// Base ID for all qTips
QTIP.nextid = 0;

// Inactive events array
QTIP.inactiveEvents = INACTIVE_EVENTS;

// Base z-index for all qTips
QTIP.zindex = 15000;

// Define configuration defaults
QTIP.defaults = {
	prerender: FALSE,
	id: FALSE,
	overwrite: TRUE,
	suppress: TRUE,
	content: {
		text: TRUE,
		attr: 'title',
		title: FALSE,
		button: FALSE
	},
	position: {
		my: 'top left',
		at: 'bottom right',
		target: FALSE,
		container: FALSE,
		viewport: FALSE,
		adjust: {
			x: 0, y: 0,
			mouse: TRUE,
			scroll: TRUE,
			resize: TRUE,
			method: 'flipinvert flipinvert'
		},
		effect: function(api, pos, viewport) {
			$(this).animate(pos, {
				duration: 200,
				queue: FALSE
			});
		}
	},
	show: {
		target: FALSE,
		event: 'mouseenter',
		effect: TRUE,
		delay: 90,
		solo: FALSE,
		ready: FALSE,
		autofocus: FALSE
	},
	hide: {
		target: FALSE,
		event: 'mouseleave',
		effect: TRUE,
		delay: 0,
		fixed: FALSE,
		inactive: FALSE,
		leave: 'window',
		distance: FALSE
	},
	style: {
		classes: '',
		widget: FALSE,
		width: FALSE,
		height: FALSE,
		def: TRUE
	},
	events: {
		render: NULL,
		move: NULL,
		show: NULL,
		hide: NULL,
		toggle: NULL,
		visible: NULL,
		hidden: NULL,
		focus: NULL,
		blur: NULL
	}
};

;var TIP, 

// .bind()/.on() namespace
TIPNS = '.qtip-tip',

// Common CSS strings
MARGIN = 'margin',
BORDER = 'border',
COLOR = 'color',
BG_COLOR = 'background-color',
TRANSPARENT = 'transparent',
IMPORTANT = ' !important',

// Check if the browser supports <canvas/> elements
HASCANVAS = !!document.createElement('canvas').getContext,

// Invalid colour values used in parseColours()
INVALID = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i;

// Camel-case method, taken from jQuery source
// http://code.jquery.com/jquery-1.8.0.js
function camel(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

/*
 * Modified from Modernizr's testPropsAll()
 * http://modernizr.com/downloads/modernizr-latest.js
 */
var cssProps = {}, cssPrefixes = ["Webkit", "O", "Moz", "ms"];
function vendorCss(elem, prop) {
	var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
		props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),
		cur, val, i = 0;

	// If the property has already been mapped...
	if(cssProps[prop]) { return elem.css(cssProps[prop]); }

	while((cur = props[i++])) {
		if((val = elem.css(cur)) !== undefined) {
			return cssProps[prop] = cur, val;
		}
	}
}

// Parse a given elements CSS property into an int
function intCss(elem, prop) {
	return Math.ceil(parseFloat(vendorCss(elem, prop)));
}


// VML creation (for IE only)
if(!HASCANVAS) {
	var createVML = function(tag, props, style) {
		return '<qtipvml:'+tag+' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" '+(props||'')+
			' style="behavior: url(#default#VML); '+(style||'')+ '" />';
	};
}

// Canvas only definitions
else {
	var PIXEL_RATIO = window.devicePixelRatio || 1,
		BACKING_STORE_RATIO = (function() {
			var context = document.createElement('canvas').getContext('2d');
			return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || 
					context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
		}()),
		SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;
}


function Tip(qtip, options) {
	this._ns = 'tip';
	this.options = options;
	this.offset = options.offset;
	this.size = [ options.width, options.height ];

	// Initialize
	this.init( (this.qtip = qtip) );
}

$.extend(Tip.prototype, {
	init: function(qtip) {
		var context, tip;

		// Create tip element and prepend to the tooltip
		tip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE+'-tip' }).prependTo(qtip.tooltip);

		// Create tip drawing element(s)
		if(HASCANVAS) {
			// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!
			context = $('<canvas />').appendTo(this.element)[0].getContext('2d');

			// Setup constant parameters
			context.lineJoin = 'miter';
			context.miterLimit = 100000;
			context.save();
		}
		else {
			context = createVML('shape', 'coordorigin="0,0"', 'position:absolute;');
			this.element.html(context + context);

			// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML
			qtip._bind( $('*', tip).add(tip), ['click', 'mousedown'], function(event) { event.stopPropagation(); }, this._ns);
		}

		// Bind update events
		qtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);

		// Create it
		this.create();
	},

	_swapDimensions: function() {
		this.size[0] = this.options.height;
		this.size[1] = this.options.width;
	},
	_resetDimensions: function() {
		this.size[0] = this.options.width;
		this.size[1] = this.options.height;
	},

	_useTitle: function(corner) {
		var titlebar = this.qtip.elements.titlebar;
		return titlebar && (
			corner.y === TOP || (corner.y === CENTER && this.element.position().top + (this.size[1] / 2) + this.options.offset < titlebar.outerHeight(TRUE))
		);
	},

	_parseCorner: function(corner) {
		var my = this.qtip.options.position.my;

		// Detect corner and mimic properties
		if(corner === FALSE || my === FALSE) {
			corner = FALSE;
		}
		else if(corner === TRUE) {
			corner = new CORNER( my.string() );
		}
		else if(!corner.string) {
			corner = new CORNER(corner);
			corner.fixed = TRUE;
		}

		return corner;
	},

	_parseWidth: function(corner, side, use) {
		var elements = this.qtip.elements,
			prop = BORDER + camel(side) + 'Width';

		return (use ? intCss(use, prop) : (
			intCss(elements.content, prop) ||
			intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
			intCss(elements.tooltip, prop)
		)) || 0;
	},

	_parseRadius: function(corner) {
		var elements = this.qtip.elements,
			prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';

		return BROWSER.ie < 9 ? 0 :
			intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || 
			intCss(elements.tooltip, prop) || 0;
	},

	_invalidColour: function(elem, prop, compare) {
		var val = elem.css(prop);
		return !val || (compare && val === elem.css(compare)) || INVALID.test(val) ? FALSE : val;
	},

	_parseColours: function(corner) {
		var elements = this.qtip.elements,
			tip = this.element.css('cssText', ''),
			borderSide = BORDER + camel(corner[ corner.precedance ]) + camel(COLOR),
			colorElem = this._useTitle(corner) && elements.titlebar || elements.content,
			css = this._invalidColour, color = [];

		// Attempt to detect the background colour from various elements, left-to-right precedance
		color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) || 
			css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);

		// Attempt to detect the correct border side colour from various elements, left-to-right precedance
		color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) || 
			css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);

		// Reset background and border colours
		$('*', tip).add(tip).css('cssText', BG_COLOR+':'+TRANSPARENT+IMPORTANT+';'+BORDER+':0'+IMPORTANT+';');

		return color;
	},

	_calculateSize: function(corner) {
		var y = corner.precedance === Y,
			width = this.options['width'],
			height = this.options['height'],
			isCenter = corner.abbrev() === 'c',
			base = (y ? width: height) * (isCenter ? 0.5 : 1),
			pow = Math.pow,
			round = Math.round,
			bigHyp, ratio, result,

		smallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),
		hyp = [ (this.border / base) * smallHyp, (this.border / height) * smallHyp ];

		hyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(this.border, 2) );
		hyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(this.border, 2) );

		bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
		ratio = bigHyp / smallHyp;

		result = [ round(ratio * width), round(ratio * height) ];
		return y ? result : result.reverse();
	},

	// Tip coordinates calculator
	_calculateTip: function(corner, size, scale) {
		scale = scale || 1;
		size = size || this.size;

		var width = size[0] * scale,
			height = size[1] * scale,
			width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),

		// Define tip coordinates in terms of height and width values
		tips = {
			br:	[0,0,		width,height,	width,0],
			bl:	[0,0,		width,0,		0,height],
			tr:	[0,height,	width,0,		width,height],
			tl:	[0,0,		0,height,		width,height],
			tc:	[0,height,	width2,0,		width,height],
			bc:	[0,0,		width,0,		width2,height],
			rc:	[0,0,		width,height2,	0,height],
			lc:	[width,0,	width,height,	0,height2]
		};

		// Set common side shapes
		tips.lt = tips.br; tips.rt = tips.bl;
		tips.lb = tips.tr; tips.rb = tips.tl;

		return tips[ corner.abbrev() ];
	},

	// Tip coordinates drawer (canvas)
	_drawCoords: function(context, coords) {
		context.beginPath();
		context.moveTo(coords[0], coords[1]);
		context.lineTo(coords[2], coords[3]);
		context.lineTo(coords[4], coords[5]);
		context.closePath();
	},

	create: function() {
		// Determine tip corner
		var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);
		
		// If we have a tip corner...
		if( (this.enabled = !!this.corner && this.corner.abbrev() !== 'c') ) {
			// Cache it
			this.qtip.cache.corner = c.clone();

			// Create it
			this.update();
		}

		// Toggle tip element
		this.element.toggle(this.enabled);

		return this.corner;
	},

	update: function(corner, position) {
		if(!this.enabled) { return this; }

		var elements = this.qtip.elements,
			tip = this.element,
			inner = tip.children(),
			options = this.options,
			curSize = this.size,
			mimic = options.mimic,
			round = Math.round,
			color, precedance, context,
			coords, bigCoords, translate, newSize, border, BACKING_STORE_RATIO;

		// Re-determine tip if not already set
		if(!corner) { corner = this.qtip.cache.corner || this.corner; }

		// Use corner property if we detect an invalid mimic value
		if(mimic === FALSE) { mimic = corner; }

		// Otherwise inherit mimic properties from the corner object as necessary
		else {
			mimic = new CORNER(mimic);
			mimic.precedance = corner.precedance;

			if(mimic.x === 'inherit') { mimic.x = corner.x; }
			else if(mimic.y === 'inherit') { mimic.y = corner.y; }
			else if(mimic.x === mimic.y) {
				mimic[ corner.precedance ] = corner[ corner.precedance ];
			}
		}
		precedance = mimic.precedance;

		// Ensure the tip width.height are relative to the tip position
		if(corner.precedance === X) { this._swapDimensions(); }
		else { this._resetDimensions(); }

		// Update our colours
		color = this.color = this._parseColours(corner);

		// Detect border width, taking into account colours
		if(color[1] !== TRANSPARENT) {
			// Grab border width
			border = this.border = this._parseWidth(corner, corner[corner.precedance]);

			// If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)
			if(options.border && border < 1 && !INVALID.test(color[1])) { color[0] = color[1]; }

			// Set border width (use detected border width if options.border is true)
			this.border = border = options.border !== TRUE ? options.border : border;
		}

		// Border colour was invalid, set border to zero
		else { this.border = border = 0; }

		// Determine tip size
		newSize = this.size = this._calculateSize(corner);
		tip.css({
			width: newSize[0],
			height: newSize[1],
			lineHeight: newSize[1]+'px'
		});

		// Calculate tip translation
		if(corner.precedance === Y) {
			translate = [
				round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2),
				round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)
			];
		}
		else {
			translate = [
				round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0),
				round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)
			];
		}

		// Canvas drawing implementation
		if(HASCANVAS) {
			// Grab canvas context and clear/save it
			context = inner[0].getContext('2d');
			context.restore(); context.save();
			context.clearRect(0,0,6000,6000);
			
			// Calculate coordinates
			coords = this._calculateTip(mimic, curSize, SCALE);
			bigCoords = this._calculateTip(mimic, this.size, SCALE);

			// Set the canvas size using calculated size
			inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);
			inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);

			// Draw the outer-stroke tip
			this._drawCoords(context, bigCoords);
			context.fillStyle = color[1];
			context.fill();

			// Draw the actual tip
			context.translate(translate[0] * SCALE, translate[1] * SCALE);
			this._drawCoords(context, coords);
			context.fillStyle = color[0];
			context.fill();
		}

		// VML (IE Proprietary implementation)
		else {
			// Calculate coordinates
			coords = this._calculateTip(mimic);

			// Setup coordinates string
			coords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] +
				',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';

			// Setup VML-specific offset for pixel-perfection
			translate[2] = border && /^(r|b)/i.test(corner.string()) ?
				BROWSER.ie === 8 ? 2 : 1 : 0;

			// Set initial CSS
			inner.css({
				coordsize: (newSize[0]+border) + ' ' + (newSize[1]+border),
				antialias: ''+(mimic.string().indexOf(CENTER) > -1),
				left: translate[0] - (translate[2] * Number(precedance === X)),
				top: translate[1] - (translate[2] * Number(precedance === Y)),
				width: newSize[0] + border,
				height: newSize[1] + border
			})
			.each(function(i) {
				var $this = $(this);

				// Set shape specific attributes
				$this[ $this.prop ? 'prop' : 'attr' ]({
					coordsize: (newSize[0]+border) + ' ' + (newSize[1]+border),
					path: coords,
					fillcolor: color[0],
					filled: !!i,
					stroked: !i
				})
				.toggle(!!(border || i));

				// Check if border is enabled and add stroke element
				!i && $this.html( createVML(
					'stroke', 'weight="'+(border*2)+'px" color="'+color[1]+'" miterlimit="1000" joinstyle="miter"'
				) );
			});
		}

		// Opera bug #357 - Incorrect tip position
		// https://github.com/Craga89/qTip2/issues/367
		window.opera && setTimeout(function() {
			elements.tip.css({
				display: 'inline-block',
				visibility: 'visible'
			});
		}, 1);

		// Position if needed
		if(position !== FALSE) { this.calculate(corner, newSize); }
	},

	calculate: function(corner, size) {
		if(!this.enabled) { return FALSE; }

		var self = this,
			elements = this.qtip.elements,
			tip = this.element,
			userOffset = this.options.offset,
			isWidget = elements.tooltip.hasClass('ui-widget'),
			position = {  },
			precedance, corners;

		// Inherit corner if not provided
		corner = corner || this.corner;
		precedance = corner.precedance;

		// Determine which tip dimension to use for adjustment
		size = size || this._calculateSize(corner);

		// Setup corners and offset array
		corners = [ corner.x, corner.y ];
		if(precedance === X) { corners.reverse(); }

		// Calculate tip position
		$.each(corners, function(i, side) {
			var b, bc, br;

			if(side === CENTER) {
				b = precedance === Y ? LEFT : TOP;
				position[ b ] = '50%';
				position[MARGIN+'-' + b] = -Math.round(size[ precedance === Y ? 0 : 1 ] / 2) + userOffset;
			}
			else {
				b = self._parseWidth(corner, side, elements.tooltip);
				bc = self._parseWidth(corner, side, elements.content);
				br = self._parseRadius(corner);

				position[ side ] = Math.max(-self.border, i ? bc : (userOffset + (br > b ? br : -b)));
			}
		});

		// Adjust for tip size
		position[ corner[precedance] ] -= size[ precedance === X ? 0 : 1 ];

		// Set and return new position
		tip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);
		return position;
	},

	reposition: function(event, api, pos, viewport) {
		if(!this.enabled) { return; }

		var cache = api.cache,
			newCorner = this.corner.clone(),
			adjust = pos.adjusted,
			method = api.options.position.adjust.method.split(' '),
			horizontal = method[0],
			vertical = method[1] || method[0],
			shift = { left: FALSE, top: FALSE, x: 0, y: 0 },
			offset, css = {}, props;

		function shiftflip(direction, precedance, popposite, side, opposite) {
			// Horizontal - Shift or flip method
			if(direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {
				newCorner.precedance = newCorner.precedance === X ? Y : X;
			}
			else if(direction !== SHIFT && adjust[side]){
				newCorner[precedance] = newCorner[precedance] === CENTER ? 
					(adjust[side] > 0 ? side : opposite) : (newCorner[precedance] === side ? opposite : side);
			}
		}

		function shiftonly(xy, side, opposite) {
			if(newCorner[xy] === CENTER) {
				css[MARGIN+'-'+side] = shift[xy] = offset[MARGIN+'-'+side] - adjust[side];
			}
			else {
				props = offset[opposite] !== undefined ?
					[ adjust[side], -offset[side] ] : [ -adjust[side], offset[side] ];

				if( (shift[xy] = Math.max(props[0], props[1])) > props[0] ) {
					pos[side] -= adjust[side];
					shift[side] = FALSE;
				}
				
				css[ offset[opposite] !== undefined ? opposite : side ] = shift[xy];
			}
		}

		// If our tip position isn't fixed e.g. doesn't adjust with viewport...
		if(this.corner.fixed !== TRUE) {
			// Perform shift/flip adjustments
			shiftflip(horizontal, X, Y, LEFT, RIGHT);
			shiftflip(vertical, Y, X, TOP, BOTTOM);

			// Update and redraw the tip if needed (check cached details of last drawn tip)
			if(newCorner.string() !== cache.corner.string() && (cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left)) {
				this.update(newCorner, FALSE);
			}
		}

		// Setup tip offset properties
		offset = this.calculate(newCorner);

		// Readjust offset object to make it left/top
		if(offset.right !== undefined) { offset.left = -offset.right; }
		if(offset.bottom !== undefined) { offset.top = -offset.bottom; }
		offset.user = this.offset;

		// Perform shift adjustments
		if(shift.left = (horizontal === SHIFT && !!adjust.left)) { shiftonly(X, LEFT, RIGHT); }
		if(shift.top = (vertical === SHIFT && !!adjust.top)) { shiftonly(Y, TOP, BOTTOM); }

		/*
		* If the tip is adjusted in both dimensions, or in a
		* direction that would cause it to be anywhere but the
		* outer border, hide it!
		*/
		this.element.css(css).toggle(
			!((shift.x && shift.y) || (newCorner.x === CENTER && shift.y) || (newCorner.y === CENTER && shift.x))
		);

		// Adjust position to accomodate tip dimensions
		pos.left -= offset.left.charAt ? offset.user : 
			horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;
		pos.top -= offset.top.charAt ? offset.user : 
			vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;

		// Cache details
		cache.cornerLeft = adjust.left; cache.cornerTop = adjust.top;
		cache.corner = newCorner.clone();
	},

	destroy: function() {
		// Unbind events
		this.qtip._unbind(this.qtip.tooltip, this._ns);

		// Remove the tip element(s)
		if(this.qtip.elements.tip) {
			this.qtip.elements.tip.find('*')
				.remove().end().remove();
		}
	}
});

TIP = PLUGINS.tip = function(api) {
	return new Tip(api, api.options.style.tip);
};

// Initialize tip on render
TIP.initialize = 'render';

// Setup plugin sanitization options
TIP.sanitize = function(options) {
	if(options.style && 'tip' in options.style) {
		var opts = options.style.tip;
		if(typeof opts !== 'object') { opts = options.style.tip = { corner: opts }; }
		if(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }
	}
};

// Add new option checks for the plugin
CHECKS.tip = {
	'^position.my|style.tip.(corner|mimic|border)$': function() {
		// Make sure a tip can be drawn
		this.create();
		
		// Reposition the tooltip
		this.qtip.reposition();
	},
	'^style.tip.(height|width)$': function(obj) {
		// Re-set dimensions and redraw the tip
		this.size = [ obj.width, obj.height ];
		this.update();

		// Reposition the tooltip
		this.qtip.reposition();
	},
	'^content.title|style.(classes|widget)$': function() {
		this.update();
	}
};

// Extend original qTip defaults
$.extend(TRUE, QTIP.defaults, {
	style: {
		tip: {
			corner: TRUE,
			mimic: FALSE,
			width: 6,
			height: 6,
			border: TRUE,
			offset: 0
		}
	}
});

;var MODAL, OVERLAY,
	MODALCLASS = 'qtip-modal',
	MODALSELECTOR = '.'+MODALCLASS;

OVERLAY = function()
{
	var self = this,
		focusableElems = {},
		current, onLast,
		prevState, elem;

	// Modified code from jQuery UI 1.10.0 source
	// http://code.jquery.com/ui/1.10.0/jquery-ui.js
	function focusable(element) {
		// Use the defined focusable checker when possible
		if($.expr[':'].focusable) { return $.expr[':'].focusable; }

		var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),
			nodeName = element.nodeName && element.nodeName.toLowerCase(),
			map, mapName, img;

		if('area' === nodeName) {
			map = element.parentNode;
			mapName = map.name;
			if(!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
				return false;
			}
			img = $('img[usemap=#' + mapName + ']')[0];
			return !!img && img.is(':visible');
		}
		return (/input|select|textarea|button|object/.test( nodeName ) ?
				!element.disabled :
				'a' === nodeName ? 
					element.href || isTabIndexNotNaN : 
					isTabIndexNotNaN
			);
	}

	// Focus inputs using cached focusable elements (see update())
	function focusInputs(blurElems) {
		// Blurring body element in IE causes window.open windows to unfocus!
		if(focusableElems.length < 1 && blurElems.length) { blurElems.not('body').blur(); }

		// Focus the inputs
		else { focusableElems.first().focus(); }
	}

	// Steal focus from elements outside tooltip
	function stealFocus(event) {
		if(!elem.is(':visible')) { return; }

		var target = $(event.target),
			tooltip = current.tooltip,
			container = target.closest(SELECTOR),
			targetOnTop;

		// Determine if input container target is above this
		targetOnTop = container.length < 1 ? FALSE :
			(parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10));

		// If we're showing a modal, but focus has landed on an input below
		// this modal, divert focus to the first visible input in this modal
		// or if we can't find one... the tooltip itself
		if(!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {
			focusInputs(target);
		}

		// Detect when we leave the last focusable element...
		onLast = event.target === focusableElems[focusableElems.length - 1];
	}

	$.extend(self, {
		init: function() {
			// Create document overlay
			elem = self.elem = $('<div />', {
				id: 'qtip-overlay',
				html: '<div></div>',
				mousedown: function() { return FALSE; }
			})
			.hide();

			// Make sure we can't focus anything outside the tooltip
			$(document.body).bind('focusin'+MODALSELECTOR, stealFocus);

			// Apply keyboard "Escape key" close handler
			$(document).bind('keydown'+MODALSELECTOR, function(event) {
				if(current && current.options.show.modal.escape && event.keyCode === 27) {
					current.hide(event);
				}
			});

			// Apply click handler for blur option
			elem.bind('click'+MODALSELECTOR, function(event) {
				if(current && current.options.show.modal.blur) {
					current.hide(event);
				}
			});

			return self;
		},

		update: function(api) {
			// Update current API reference
			current = api;

			// Update focusable elements if enabled
			if(api.options.show.modal.stealfocus !== FALSE) {
				focusableElems = api.tooltip.find('*').filter(function() {
					return focusable(this);
				});
			}
			else { focusableElems = []; }
		},

		toggle: function(api, state, duration) {
			var docBody = $(document.body),
				tooltip = api.tooltip,
				options = api.options.show.modal,
				effect = options.effect,
				type = state ? 'show': 'hide',
				visible = elem.is(':visible'),
				visibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip),
				zindex;

			// Set active tooltip API reference
			self.update(api);

			// If the modal can steal the focus...
			// Blur the current item and focus anything in the modal we an
			if(state && options.stealfocus !== FALSE) {
				focusInputs( $(':focus') );
			}

			// Toggle backdrop cursor style on show
			elem.toggleClass('blurs', options.blur);

			// Append to body on show
			if(state) {
				elem.appendTo(document.body);
			}

			// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible
			if((elem.is(':animated') && visible === state && prevState !== FALSE) || (!state && visibleModals.length)) {
				return self;
			}

			// Stop all animations
			elem.stop(TRUE, FALSE);

			// Use custom function if provided
			if($.isFunction(effect)) {
				effect.call(elem, state);
			}

			// If no effect type is supplied, use a simple toggle
			else if(effect === FALSE) {
				elem[ type ]();
			}

			// Use basic fade function
			else {
				elem.fadeTo( parseInt(duration, 10) || 90, state ? 1 : 0, function() {
					if(!state) { elem.hide(); }
				});
			}

			// Reset position and detach from body on hide
			if(!state) {
				elem.queue(function(next) {
					elem.css({ left: '', top: '' });
					if(!$(MODALSELECTOR).length) { elem.detach(); }
					next();
				});
			}

			// Cache the state
			prevState = state;

			// If the tooltip is destroyed, set reference to null
			if(current.destroyed) { current = NULL; }

			return self;
		}
	});	

	self.init();
};
OVERLAY = new OVERLAY();

function Modal(api, options) {
	this.options = options;
	this._ns = '-modal';

	this.init( (this.qtip = api) );
}

$.extend(Modal.prototype, {
	init: function(qtip) {
		var tooltip = qtip.tooltip;

		// If modal is disabled... return
		if(!this.options.on) { return this; }

		// Set overlay reference
		qtip.elements.overlay = OVERLAY.elem;

		// Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index
		tooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length);
		
		// Apply our show/hide/focus modal events
		qtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function(event, api, duration) {
			var oEvent = event.originalEvent;

			// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop
			if(event.target === tooltip[0]) {
				if(oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {
					try { event.preventDefault(); } catch(e) {}
				}
				else if(!oEvent || (oEvent && oEvent.type !== 'tooltipsolo')) {
					this.toggle(event, event.type === 'tooltipshow', duration);
				}
			}
		}, this._ns, this);

		// Adjust modal z-index on tooltip focus
		qtip._bind(tooltip, 'tooltipfocus', function(event, api) {
			// If focus was cancelled before it reached us, don't do anything
			if(event.isDefaultPrevented() || event.target !== tooltip[0]) { return; }

			var qtips = $(MODALSELECTOR),

			// Keep the modal's lower than other, regular qtips
			newIndex = QTIP.modal_zindex + qtips.length,
			curIndex = parseInt(tooltip[0].style.zIndex, 10);

			// Set overlay z-index
			OVERLAY.elem[0].style.zIndex = newIndex - 1;

			// Reduce modal z-index's and keep them properly ordered
			qtips.each(function() {
				if(this.style.zIndex > curIndex) {
					this.style.zIndex -= 1;
				}
			});

			// Fire blur event for focused tooltip
			qtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent);

			// Set the new z-index
			tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;

			// Set current
			OVERLAY.update(api);

			// Prevent default handling
			try { event.preventDefault(); } catch(e) {}
		}, this._ns, this);

		// Focus any other visible modals when this one hides
		qtip._bind(tooltip, 'tooltiphide', function(event) {
			if(event.target === tooltip[0]) {
				$(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);
			}
		}, this._ns, this);
	},

	toggle: function(event, state, duration) {
		// Make sure default event hasn't been prevented
		if(event && event.isDefaultPrevented()) { return this; }

		// Toggle it
		OVERLAY.toggle(this.qtip, !!state, duration);
	},

	destroy: function() {
		// Remove modal class
		this.qtip.tooltip.removeClass(MODALCLASS);

		// Remove bound events
		this.qtip._unbind(this.qtip.tooltip, this._ns);

		// Delete element reference
		OVERLAY.toggle(this.qtip, FALSE);
		delete this.qtip.elements.overlay;
	}
});


MODAL = PLUGINS.modal = function(api) {
	return new Modal(api, api.options.show.modal);
};

// Setup sanitiztion rules
MODAL.sanitize = function(opts) {
	if(opts.show) { 
		if(typeof opts.show.modal !== 'object') { opts.show.modal = { on: !!opts.show.modal }; }
		else if(typeof opts.show.modal.on === 'undefined') { opts.show.modal.on = TRUE; }
	}
};

// Base z-index for all modal tooltips (use qTip core z-index as a base)
QTIP.modal_zindex = QTIP.zindex - 200;

// Plugin needs to be initialized on render
MODAL.initialize = 'render';

// Setup option set checks
CHECKS.modal = {
	'^show.modal.(on|blur)$': function() {
		// Initialise
		this.destroy();
		this.init();
		
		// Show the modal if not visible already and tooltip is visible
		this.qtip.elems.overlay.toggle(
			this.qtip.tooltip[0].offsetWidth > 0
		);
	}
};

// Extend original api defaults
$.extend(TRUE, QTIP.defaults, {
	show: {
		modal: {
			on: FALSE,
			effect: TRUE,
			blur: TRUE,
			stealfocus: TRUE,
			escape: TRUE
		}
	}
});
;PLUGINS.viewport = function(api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight)
{
	var target = posOptions.target,
		tooltip = api.elements.tooltip,
		my = posOptions.my,
		at = posOptions.at,
		adjust = posOptions.adjust,
		method = adjust.method.split(' '),
		methodX = method[0],
		methodY = method[1] || method[0],
		viewport = posOptions.viewport,
		container = posOptions.container,
		cache = api.cache,
		adjusted = { left: 0, top: 0 },
		fixed, newMy, newClass, containerOffset, containerStatic,
		viewportWidth, viewportHeight, viewportScroll, viewportOffset;

	// If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return
	if(!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {
		return adjusted;
	}

	// Cach container details
	containerOffset = container.offset() || adjusted;
	containerStatic = container.css('position') === 'static';

	// Cache our viewport details
	fixed = tooltip.css('position') === 'fixed';
	viewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);
	viewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);
	viewportScroll = { left: fixed ? 0 : viewport.scrollLeft(), top: fixed ? 0 : viewport.scrollTop() };
	viewportOffset = viewport.offset() || adjusted;

	// Generic calculation method
	function calculate(side, otherSide, type, adjust, side1, side2, lengthName, targetLength, elemLength) {
		var initialPos = position[side1],
			mySide = my[side],
			atSide = at[side],
			isShift = type === SHIFT,
			myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,
			atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,
			sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),
			overflow1 = sideOffset - initialPos,
			overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,
			offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);

		// shift
		if(isShift) {
			offset = (mySide === side1 ? 1 : -1) * myLength;

			// Adjust position but keep it within viewport dimensions
			position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;
			position[side1] = Math.max(
				-containerOffset[side1] + viewportOffset[side1],
				initialPos - offset,
				Math.min(
					Math.max(
						-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight),
						initialPos + offset
					),
					position[side1],

					// Make sure we don't adjust complete off the element when using 'center'
					mySide === 'center' ? initialPos - myLength : 1E9
				)
			);

		}

		// flip/flipinvert
		else {
			// Update adjustment amount depending on if using flipinvert or flip
			adjust *= (type === FLIPINVERT ? 2 : 0);

			// Check for overflow on the left/top
			if(overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {
				position[side1] -= offset + adjust;
				newMy.invert(side, side1);
			}

			// Check for overflow on the bottom/right
			else if(overflow2 > 0 && (mySide !== side2 || overflow1 > 0)  ) {
				position[side1] -= (mySide === CENTER ? -offset : offset) + adjust;
				newMy.invert(side, side2);
			}

			// Make sure we haven't made things worse with the adjustment and reset if so
			if(position[side1] < viewportScroll && -position[side1] > overflow2) {
				position[side1] = initialPos; newMy = my.clone();
			}
		}

		return position[side1] - initialPos;
	}

	// Set newMy if using flip or flipinvert methods
	if(methodX !== 'shift' || methodY !== 'shift') { newMy = my.clone(); }

	// Adjust position based onviewport and adjustment options
	adjusted = {
		left: methodX !== 'none' ? calculate( X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth ) : 0,
		top: methodY !== 'none' ? calculate( Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight ) : 0
	};

	// Set tooltip position class if it's changed
	if(newMy && cache.lastClass !== (newClass = NAMESPACE + '-pos-' + newMy.abbrev())) {
		tooltip.removeClass(api.cache.lastClass).addClass( (api.cache.lastClass = newClass) );
	}

	return adjusted;
};
;PLUGINS.polys = {
	// POLY area coordinate calculator
	//	Special thanks to Ed Cradock for helping out with this.
	//	Uses a binary search algorithm to find suitable coordinates.
	polygon: function(baseCoords, corner) {
		var result = {
			width: 0, height: 0,
			position: {
				top: 1e10, right: 0,
				bottom: 0, left: 1e10
			},
			adjustable: FALSE
		},
		i = 0, next,
		coords = [],
		compareX = 1, compareY = 1,
		realX = 0, realY = 0,
		newWidth, newHeight;

		// First pass, sanitize coords and determine outer edges
		i = baseCoords.length; while(i--) {
			next = [ parseInt(baseCoords[--i], 10), parseInt(baseCoords[i+1], 10) ];

			if(next[0] > result.position.right){ result.position.right = next[0]; }
			if(next[0] < result.position.left){ result.position.left = next[0]; }
			if(next[1] > result.position.bottom){ result.position.bottom = next[1]; }
			if(next[1] < result.position.top){ result.position.top = next[1]; }

			coords.push(next);
		}

		// Calculate height and width from outer edges
		newWidth = result.width = Math.abs(result.position.right - result.position.left);
		newHeight = result.height = Math.abs(result.position.bottom - result.position.top);

		// If it's the center corner...
		if(corner.abbrev() === 'c') {
			result.position = {
				left: result.position.left + (result.width / 2),
				top: result.position.top + (result.height / 2)
			};
		}
		else {
			// Second pass, use a binary search algorithm to locate most suitable coordinate
			while(newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0)
			{
				newWidth = Math.floor(newWidth / 2);
				newHeight = Math.floor(newHeight / 2);

				if(corner.x === LEFT){ compareX = newWidth; }
				else if(corner.x === RIGHT){ compareX = result.width - newWidth; }
				else{ compareX += Math.floor(newWidth / 2); }

				if(corner.y === TOP){ compareY = newHeight; }
				else if(corner.y === BOTTOM){ compareY = result.height - newHeight; }
				else{ compareY += Math.floor(newHeight / 2); }

				i = coords.length; while(i--)
				{
					if(coords.length < 2){ break; }

					realX = coords[i][0] - result.position.left;
					realY = coords[i][1] - result.position.top;

					if((corner.x === LEFT && realX >= compareX) ||
					(corner.x === RIGHT && realX <= compareX) ||
					(corner.x === CENTER && (realX < compareX || realX > (result.width - compareX))) ||
					(corner.y === TOP && realY >= compareY) ||
					(corner.y === BOTTOM && realY <= compareY) ||
					(corner.y === CENTER && (realY < compareY || realY > (result.height - compareY)))) {
						coords.splice(i, 1);
					}
				}
			}
			result.position = { left: coords[0][0], top: coords[0][1] };
		}

		return result;
	},

	rect: function(ax, ay, bx, by) {
		return {
			width: Math.abs(bx - ax),
			height: Math.abs(by - ay),
			position: {
				left: Math.min(ax, bx),
				top: Math.min(ay, by)
			}
		};
	},

	_angles: {
		tc: 3 / 2, tr: 7 / 4, tl: 5 / 4, 
		bc: 1 / 2, br: 1 / 4, bl: 3 / 4, 
		rc: 2, lc: 1, c: 0
	},
	ellipse: function(cx, cy, rx, ry, corner) {
		var c = PLUGINS.polys._angles[ corner.abbrev() ],
			rxc = c === 0 ? 0 : rx * Math.cos( c * Math.PI ),
			rys = ry * Math.sin( c * Math.PI );

		return {
			width: (rx * 2) - Math.abs(rxc),
			height: (ry * 2) - Math.abs(rys),
			position: {
				left: cx + rxc,
				top: cy + rys
			},
			adjustable: FALSE
		};
	},
	circle: function(cx, cy, r, corner) {
		return PLUGINS.polys.ellipse(cx, cy, r, r, corner);
	}
};;PLUGINS.svg = function(api, svg, corner)
{
	var doc = $(document),
		elem = svg[0],
		root = $(elem.ownerSVGElement),
		xScale = 1, yScale = 1,
		complex = true,
		rootWidth, rootHeight,
		mtx, transformed, viewBox,
		len, next, i, points,
		result, position, dimensions;

	// Ascend the parentNode chain until we find an element with getBBox()
	while(!elem.getBBox) { elem = elem.parentNode; }
	if(!elem.getBBox || !elem.parentNode) { return FALSE; }

	// Determine dimensions where possible
	rootWidth = root.attr('width') || root.width() || parseInt(root.css('width'), 10);
	rootHeight = root.attr('height') || root.height() || parseInt(root.css('height'), 10);

	// Add stroke characteristics to scaling
	var strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2;
	if(strokeWidth2) {
		xScale += strokeWidth2 / rootWidth;
		yScale += strokeWidth2 / rootHeight;
	}

	// Determine which shape calculation to use
	switch(elem.nodeName) {
		case 'ellipse':
		case 'circle':
			result = PLUGINS.polys.ellipse(
				elem.cx.baseVal.value,
				elem.cy.baseVal.value,
				(elem.rx || elem.r).baseVal.value + strokeWidth2,
				(elem.ry || elem.r).baseVal.value + strokeWidth2,
				corner
			);
		break;

		case 'line':
		case 'polygon':
		case 'polyline':
			// Determine points object (line has none, so mimic using array)
			points = elem.points || [ 
				{ x: elem.x1.baseVal.value, y: elem.y1.baseVal.value },
				{ x: elem.x2.baseVal.value, y: elem.y2.baseVal.value }
			];

			for(result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {
				next = points.getItem ? points.getItem(i) : points[i];
				result.push.apply(result, [next.x, next.y]);
			}

			result = PLUGINS.polys.polygon(result, corner);
		break;

		// Unknown shape or rectangle? Use bounding box
		default:
			result = elem.getBoundingClientRect();
			result = {
				width: result.width, height: result.height,
				position: {
					left: result.left,
					top: result.top
				}
			};
			complex = false;
		break;
	}

	// Shortcut assignments
	position = result.position;
	root = root[0];

	// If the shape was complex (i.e. not using bounding box calculations)
	if(complex) {
		// Convert position into a pixel value
		if(root.createSVGPoint) {
			mtx = elem.getScreenCTM();
			points = root.createSVGPoint();

			points.x = position.left;
			points.y = position.top;
			transformed = points.matrixTransform( mtx );
			position.left = transformed.x;
			position.top = transformed.y;
		}

		// Calculate viewBox characteristics
		if(root.viewBox && (viewBox = root.viewBox.baseVal) && viewBox.width && viewBox.height) {
			xScale *= rootWidth / viewBox.width;
			yScale *= rootHeight / viewBox.height;
		}
	}

	// Adjust by scroll offset
	position.left += doc.scrollLeft();
	position.top += doc.scrollTop();

	return result;
};;PLUGINS.imagemap = function(api, area, corner, adjustMethod)
{
	if(!area.jquery) { area = $(area); }

	var shape = area.attr('shape').toLowerCase().replace('poly', 'polygon'),
		image = $('img[usemap="#'+area.parent('map').attr('name')+'"]'),
		coordsString = $.trim(area.attr('coords')),
		coordsArray = coordsString.replace(/,$/, '').split(','),
		imageOffset, coords, i, next, result, len;

	// If we can't find the image using the map...
	if(!image.length) { return FALSE; }

	// Pass coordinates string if polygon
	if(shape === 'polygon') {
		result = PLUGINS.polys.polygon(coordsArray, corner);
	}

	// Otherwise parse the coordinates and pass them as arguments
	else if(PLUGINS.polys[shape]) {
		for(i = -1, len = coordsArray.length, coords = []; ++i < len;) {
			coords.push( parseInt(coordsArray[i], 10) );
		}

		result = PLUGINS.polys[shape].apply(
			this, coords.concat(corner)
		);
	}

	// If no shapre calculation method was found, return false
	else { return FALSE; }

	// Make sure we account for padding and borders on the image
	imageOffset = image.offset();
	imageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);
	imageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);

	// Add image position to offset coordinates
	result.position.left += imageOffset.left;
	result.position.top += imageOffset.top;

	return result;
};;var IE6,

/* 
 * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)
 * Special thanks to Brandon Aaron
 */
BGIFRAME = '<iframe class="qtip-bgiframe" frameborder="0" tabindex="-1" src="javascript:\'\';" ' +
	' style="display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' +
		'-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";"></iframe>';

function Ie6(api, qtip) {
	this._ns = 'ie6';
	this.init( (this.qtip = api) );
}

$.extend(Ie6.prototype, {
	_scroll : function() {
		var overlay = this.qtip.elements.overlay;
		overlay && (overlay[0].style.top = $(window).scrollTop() + 'px');
	},

	init: function(qtip) {
		var tooltip = qtip.tooltip,
			scroll;

		// Create the BGIFrame element if needed
		if($('select, object').length < 1) {
			this.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);

			// Update BGIFrame on tooltip move
			qtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);
		}

		// redraw() container for width/height calculations
		this.redrawContainer = $('<div/>', { id: NAMESPACE+'-rcontainer' })
			.appendTo(document.body);

		// Fixup modal plugin if present too
		if( qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix') ) {
			qtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);
			qtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);
		}

		// Set dimensions
		this.redraw();
	},

	adjustBGIFrame: function() {
		var tooltip = this.qtip.tooltip,
			dimensions = {
				height: tooltip.outerHeight(FALSE),
				width: tooltip.outerWidth(FALSE)
			},
			plugin = this.qtip.plugins.tip,
			tip = this.qtip.elements.tip,
			tipAdjust, offset;

		// Adjust border offset
		offset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;
		offset = { left: -offset, top: -offset };

		// Adjust for tips plugin
		if(plugin && tip) {
			tipAdjust = (plugin.corner.precedance === 'x') ? [WIDTH, LEFT] : [HEIGHT, TOP];
			offset[ tipAdjust[1] ] -= tip[ tipAdjust[0] ]();
		}

		// Update bgiframe
		this.bgiframe.css(offset).css(dimensions);
	},

	// Max/min width simulator function
	redraw: function() {
		if(this.qtip.rendered < 1 || this.drawing) { return this; }

		var tooltip = this.qtip.tooltip,
			style = this.qtip.options.style,
			container = this.qtip.options.position.container,
			perc, width, max, min;

		// Set drawing flag
		this.qtip.drawing = 1;

		// If tooltip has a set height/width, just set it... like a boss!
		if(style.height) { tooltip.css(HEIGHT, style.height); }
		if(style.width) { tooltip.css(WIDTH, style.width); }

		// Simulate max/min width if not set width present...
		else {
			// Reset width and add fluid class
			tooltip.css(WIDTH, '').appendTo(this.redrawContainer);

			// Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)
			width = tooltip.width();
			if(width % 2 < 1) { width += 1; }

			// Grab our max/min properties
			max = tooltip.css('maxWidth') || '';
			min = tooltip.css('minWidth') || '';

			// Parse into proper pixel values
			perc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;
		max = ((max.indexOf('%') > -1 ? perc : 1) * parseInt(max, 10)) || width;
			min = ((min.indexOf('%') > -1 ? perc : 1) * parseInt(min, 10)) || 0;

			// Determine new dimension size based on max/min/current values
			width = max + min ? Math.min(Math.max(width, min), max) : width;

			// Set the newly calculated width and remvoe fluid class
			tooltip.css(WIDTH, Math.round(width)).appendTo(container);
		}

		// Set drawing flag
		this.drawing = 0;

		return this;
	},

	destroy: function() {
		// Remove iframe
		this.bgiframe && this.bgiframe.remove();

		// Remove bound events
		this.qtip._unbind([window, this.qtip.tooltip], this._ns);
	}
});

IE6 = PLUGINS.ie6 = function(api) {
	// Proceed only if the browser is IE6
	return BROWSER.ie === 6 ? new Ie6(api) : FALSE;
};

IE6.initialize = 'render';

CHECKS.ie6 = {
	'^content|style$': function() { 
		this.redraw();
	}
};;}));
}( window, document ));


;/*
*	TypeWatch 2.2
*
*	Examples/Docs: github.com/dennyferra/TypeWatch
*	
*  Copyright(c) 2013 
*	Denny Ferrassoli - dennyferra.com
*   Charles Christolini
*  
*  Dual licensed under the MIT and GPL licenses:
*  http://www.opensource.org/licenses/mit-license.php
*  http://www.gnu.org/licenses/gpl.html
*/

(function(jQuery) {
	jQuery.fn.typeWatch = function(o) {
		// The default input types that are supported
		var _supportedInputTypes =
			['TEXT', 'TEXTAREA', 'PASSWORD', 'TEL', 'SEARCH', 'URL', 'EMAIL', 'DATETIME', 'DATE', 'MONTH', 'WEEK', 'TIME', 'DATETIME-LOCAL', 'NUMBER', 'RANGE'];

		// Options
		var options = jQuery.extend({
			wait: 750,
			callback: function() { },
			highlight: true,
			captureLength: 2,
			inputTypes: _supportedInputTypes
		}, o);

		function checkElement(timer, override) {
			var value = jQuery(timer.el).val();

			// Fire if text >= options.captureLength AND text != saved text OR if override AND text >= options.captureLength
			if ((value.length >= options.captureLength && value.toUpperCase() != timer.text)
				|| (override && value.length >= options.captureLength))
			{
				timer.text = value.toUpperCase();
				timer.cb.call(timer.el, value);
			}
		};

		function watchElement(elem) {
			var elementType = elem.type.toUpperCase();
			if (jQuery.inArray(elementType, options.inputTypes) >= 0) {

				// Allocate timer element
				var timer = {
					timer: null,
					text: jQuery(elem).val().toUpperCase(),
					cb: options.callback,
					el: elem,
					wait: options.wait
				};

				// Set focus action (highlight)
				if (options.highlight) {
					jQuery(elem).focus(
						function() {
							this.select();
						});
				}

				// Key watcher / clear and reset the timer
				var startWatch = function(evt) {
					var timerWait = timer.wait;
					var overrideBool = false;
					var evtElementType = this.type.toUpperCase();

					// If enter key is pressed and not a TEXTAREA and matched inputTypes
					if (typeof evt.keyCode != 'undefined' && evt.keyCode == 13 && evtElementType != 'TEXTAREA' && jQuery.inArray(evtElementType, options.inputTypes) >= 0) {
						timerWait = 1;
						overrideBool = true;
					}

					var timerCallbackFx = function() {
						checkElement(timer, overrideBool)
					}

					// Clear timer					
					clearTimeout(timer.timer);
					timer.timer = setTimeout(timerCallbackFx, timerWait);
				};

				jQuery(elem).on('keydown paste cut input', startWatch);
			}
		};

		// Watch Each Element
		return this.each(function() {
			watchElement(this);
		});

	};
})(jQuery);;(function(a,b){var c="ui-state-active",d="ui-state-hover",e="ui-state-disabled",f=a.ui.keyCode,g=f.UP,h=f.DOWN,i=f.RIGHT,j=f.LEFT,k=f.PAGE_UP,l=f.PAGE_DOWN,m=f.HOME,n=f.END,o=a.browser.msie,p=a.browser.mozilla?"DOMMouseScroll":"mousewheel",q=".uispinner",r=[g,h,i,j,k,l,m,n,f.BACKSPACE,f.DELETE,f.TAB],s;a.widget("ui.spinner",{options:{min:null,max:null,allowNull:false,group:"",point:".",prefix:"",suffix:"",places:null,defaultStep:1,largeStep:10,mouseWheel:true,increment:"slow",className:null,showOn:"always",width:95,upIconClass:"ui-icon-triangle-1-n",downIconClass:"ui-icon-triangle-1-s",format:function(a,b){var c=this,d=/(\d+)(\d{3})/,e=(isNaN(a)?0:Math.abs(a)).toFixed(b)+"";for(e=e.replace(".",c.point);d.test(e)&&c.group;e=e.replace(d,"$1"+c.group+"$2")){}return(a<0?"-":"")+c.prefix+e+c.suffix},parse:function(a){var b=this;if(b.group==".")a=a.replace(".","");if(b.point!=".")a=a.replace(b.point,".");return parseFloat(a.replace(/[^0-9\-\.]/g,""))}},_create:function(){var a=this,b=a.element,c=b.attr("type");if(!b.is("input")||c!="text"&&c!="number"){console.error("Invalid target for ui.spinner");return}a._procOptions(true);a._createButtons(b);if(!b.is(":enabled"))a.disable()},_createButtons:function(b){function R(){if(L){a(this).removeClass(c);p._stopSpin();L=false}return false}function Q(){if(!t.disabled){var b=p.element[0],d=this===C?1:-1;b.focus();b.select();a(this).addClass(c);L=true;p._startSpin(d)}return false}function P(a){function b(){G=0;a()}if(G){if(a===H)return;clearTimeout(G)}H=a;G=setTimeout(b,100)}function O(a,b){if(K)return false;var c=String.fromCharCode(b||a),d=p.options;if(c>="0"&&c<="9"||c=="-")return false;if(p.places>0&&c==d.point||c==d.group)return false;return true}function N(a){for(var b=0;b<r.length;b++)if(r[b]==a)return true;return false}function e(a){return a=="auto"?0:parseInt(a)}var p=this,t=p.options,u=t.className,v=t.width,w=t.showOn,x=a.support.boxModel,y=b.outerHeight(),z=p.oMargin=e(b.css("margin-right")),A=p.wrapper=b.wrap('<span class="spinner-wrpr" />').css({width:(p.oWidth=x?b.width():b.outerWidth())-v,marginRight:"30px",marginLeft:"30px",textAlign:"center","float":"none",marginTop:0}).after('<span class="ui-spinner ui-widget"></span>').next(),B=p.btnContainer=a('<div class="ui-spinner-buttons">'+'<div class="ui-spinner-up ui-spinner-button ui-state-default ui-corner-tr"><span class="ui-icon '+t.upIconClass+'"> </span></div>'+'<div class="ui-spinner-down ui-spinner-button ui-state-default ui-corner-br"><span class="ui-icon '+t.downIconClass+'"> </span></div>'+"</div>"),C,D,E,F,G,H,I,J,K,L,M=b[0].dir=="rtl";if(u)A.addClass(u);A.append(B.css({height:y,left:0,top:0}));E=p.buttons=B.find(".ui-spinner-button");E.css({width:"30px",height:y-(x?E.outerHeight()-E.height():0)});E.eq(0).css({right:"0"});E.eq(1).css({left:"0"});C=E[0];D=E[1];F=E.find(".ui-icon");B.width("105px");if(w!="always")B.css("opacity",0);if(w=="hover"||w=="both")E.add(b).bind("mouseenter"+q,function(){P(function(){I=true;if(!p.focused||w=="hover")p.showButtons()})}).bind("mouseleave"+q,function S(){P(function(){I=false;if(!p.focused||w=="hover")p.hideButtons()})});E.hover(function(){p.buttons.removeClass(d);if(!t.disabled)a(this).addClass(d)},function(){a(this).removeClass(d)}).mousedown(Q).mouseup(R).mouseout(R);if(o)E.dblclick(function(){if(!t.disabled){p._change();p._doSpin((this===C?1:-1)*t.step)}return false}).bind("selectstart",function(){return false});b.bind("keydown"+q,function(b){var d,e,f,o=b.keyCode;if(b.ctrl||b.alt)return true;if(N(o))K=true;if(J)return false;switch(o){case g:case k:d=1;e=o==k;break;case h:case l:d=-1;e=o==l;break;case i:case j:d=o==i^M?1:-1;break;case m:f=p.options.min;if(f!=null)p._setValue(f);return false;case n:f=p.options.max;f=p.options.max;if(f!=null)p._setValue(f);return false}if(d){if(!J&&!t.disabled){keyDir=d;a(d>0?C:D).addClass(c);J=true;p._startSpin(d,e)}return false}}).bind("keyup"+q,function(a){if(a.ctrl||a.alt)return true;if(N(f))K=false;switch(a.keyCode){case g:case i:case k:case h:case j:case l:E.removeClass(c);p._stopSpin();J=false;return false}}).bind("keypress"+q,function(a){if(O(a.keyCode,a.charCode))return false}).bind("change"+q,function(){p._change()}).bind("focus"+q,function(){function a(){p.element.select()}o?a():setTimeout(a,0);p.focused=true;s=p;if(!I&&(w=="focus"||w=="both"))p.showButtons()}).bind("blur"+q,function(){p.focused=false;if(!I&&(w=="focus"||w=="both"))p.hideButtons()})},_procOptions:function(a){var b=this,c=b.element,d=b.options,e=d.min,f=d.max,g=d.step,h=d.places,i=-1,j;if(d.increment=="slow")d.increment=[{count:1,mult:1,delay:250},{count:3,mult:1,delay:100},{count:0,mult:1,delay:50}];else if(d.increment=="fast")d.increment=[{count:1,mult:1,delay:250},{count:19,mult:1,delay:100},{count:80,mult:1,delay:20},{count:100,mult:10,delay:20},{count:0,mult:100,delay:20}];if(e==null&&(j=c.attr("min"))!=null)e=parseFloat(j);if(f==null&&(j=c.attr("max"))!=null)f=parseFloat(j);if(!g&&(j=c.attr("step"))!=null)if(j!="any"){g=parseFloat(j);d.largeStep*=g}d.step=g=g||d.defaultStep;if(h==null&&(j=g+"").indexOf(".")!=-1)h=j.length-j.indexOf(".")-1;b.places=h;if(f!=null&&e!=null){if(e>f)e=f;i=Math.max(Math.max(i,d.format(f,h,c).length),d.format(e,h,c).length)}if(a)b.inputMaxLength=c[0].maxLength;j=b.inputMaxLength;if(j>0){i=i>0?Math.min(j,i):j;j=Math.pow(10,i)-1;if(f==null||f>j)f=j;j=-(j+1)/10+1;if(e==null||e<j)e=j}if(i>0)c.attr("maxlength",i);d.min=e;d.max=f;b._change();c.unbind(p+q);if(d.mouseWheel)c.bind(p+q,b._mouseWheel)},_mouseWheel:function(b){var c=a.data(this,"spinner");if(!c.options.disabled&&c.focused&&s===c){c._change();c._doSpin(((b.wheelDelta||-b.detail)>0?1:-1)*c.options.step);return false}},_setTimer:function(a,b,c){function e(){d._spin(b,c)}var d=this;d._stopSpin();d.timer=setInterval(e,a)},_stopSpin:function(){if(this.timer){clearInterval(this.timer);this.timer=0}},_startSpin:function(a,b){var c=this,d=c.options,e=d.increment;c._change();c._doSpin(a*(b?c.options.largeStep:c.options.step));if(e&&e.length>0){c.counter=0;c.incCounter=0;c._setTimer(e[0].delay,a,b)}},_spin:function(a,b){var c=this,d=c.options.increment,e=d[c.incCounter];c._doSpin(a*e.mult*(b?c.options.largeStep:c.options.step));c.counter++;if(c.counter>e.count&&c.incCounter<d.length-1){c.counter=0;e=d[++c.incCounter];c._setTimer(e.delay,a,b)}},_doSpin:function(a){var b=this,c=b.curvalue;if(c==null)c=(a>0?b.options.min:b.options.max)||0;b._setValue(c+a)},_parseValue:function(){var a=this.element.val();return a?this.options.parse(a,this.element):null},_validate:function(a){var b=this.options,c=b.min,d=b.max;if(a==null&&!b.allowNull)a=this.curvalue!=null?this.curvalue:c||d||0;if(d!=null&&a>d)return d;else if(c!=null&&a<c)return c;else return a},_change:function(){var a=this,b=a._parseValue(),c=a.options.min,d=a.options.max;if(!a.selfChange){if(isNaN(b))b=a.curvalue;a._setValue(b,true)}},_setOption:function(b,c){a.Widget.prototype._setOption.call(this,b,c);this._procOptions()},increment:function(){this._doSpin(this.options.step)},decrement:function(){this._doSpin(-this.options.step)},showButtons:function(a){var b=this.btnContainer.stop();if(a)b.css("opacity",1);else b.fadeTo("fast",1)},hideButtons:function(a){var b=this.btnContainer.stop();if(a)b.css("opacity",0);else b.fadeTo("fast",0);this.buttons.removeClass(d)},_setValue:function(a,b){var c=this;c.curvalue=a=c._validate(a);c.element.val(a!=null?c.options.format(a,c.places,c.element):"");if(!b){c.selfChange=true;c.element.change();c.selfChange=false}},value:function(a){if(arguments.length){this._setValue(a);return this.element}return this.curvalue},enable:function(){this.buttons.removeClass(e);this.element[0].disabled=false;a.Widget.prototype.enable.call(this)},disable:function(){this.buttons.addClass(e).removeClass(d);this.element[0].disabled=true;a.Widget.prototype.disable.call(this)},destroy:function(b){this.wrapper.remove();this.element.unbind(q).css({width:this.oWidth,marginRight:this.oMargin});a.Widget.prototype.destroy.call(this)}})})(jQuery)
;/********************************************************************
* Limit the characters that may be entered in a text field
* Common options: alphanumeric, alphabetic or numeric
* Kevin Sheedy, 2012
* http://github.com/KevinSheedy/jquery.alphanum
*********************************************************************/
(function( $ ){

	// API ///////////////////////////////////////////////////////////////////
	$.fn.alphanum = function(settings) {
		
		var combinedSettings = getCombinedSettingsAlphaNum(settings);

		var $collection = this;

		setupEventHandlers($collection, trimAlphaNum, combinedSettings);

		return this;
	};
	
	$.fn.alpha = function(settings) {
		
		var defaultAlphaSettings = getCombinedSettingsAlphaNum("alpha");
		var combinedSettings = getCombinedSettingsAlphaNum(settings, defaultAlphaSettings);

		var $collection = this;

		setupEventHandlers($collection, trimAlphaNum, combinedSettings);

		return this;
	};
	
	$.fn.numeric = function(settings) {
		
		var combinedSettings = getCombinedSettingsNum(settings);
		var $collection = this;

		setupEventHandlers($collection, trimNum, combinedSettings);

		$collection.blur(function(){
			numericField_Blur(this, settings);
		});

		return this;
	};
	
	// End of API /////////////////////////////////////////////////////////////
	
	
	// Start Settings ////////////////////////////////////////////////////////
	
	var DEFAULT_SETTINGS_ALPHANUM = {
		allow              : '',   // Allow extra characters
		disallow           : '',   // Disallow extra characters
		allowSpace         : true, // Allow the space character
		allowNumeric       : true, // Allow digits 0-9
		allowUpper         : true, // Allow upper case characters
		allowLower         : true, // Allow lower case characters
		allowCaseless      : true, // Allow characters that don't have both upper & lower variants - eg Arabic or Chinese
		allowLatin         : true, // a-z A-Z
		allowOtherCharSets : true, // eg �, �, Arabic, Chinese etc
		maxLength          : NaN   // eg Max Length
	}
	
	var DEFAULT_SETTINGS_NUM = {
		allowPlus           : false, // Allow the + sign
		allowMinus          : true,  // Allow the - sign
		allowThouSep        : true,  // Allow the thousands separator, default is the comma eg 12,000
		allowDecSep         : true,  // Allow the decimal separator, default is the fullstop eg 3.141
		allowLeadingSpaces  : false,
		maxDigits           : NaN,   // The max number of digits
		maxDecimalPlaces    : NaN,   // The max number of decimal places
		maxPreDecimalPlaces : NaN,   // The max number digits before the decimal point
		max                 : NaN,   // The max numeric value allowed
		min                 : NaN    // The min numeric value allowed
	}
	
	// Some pre-defined groups of settings for convenience
	var CONVENIENCE_SETTINGS_ALPHANUM = {
		"alpha" : {
			allowNumeric  : false
		},
		"upper" : {
			allowNumeric  : false,
			allowUpper    : true,
			allowLower    : false,
			allowCaseless : true
		},
		"lower" : {
			allowNumeric  : false,
			allowUpper    : false,
			allowLower    : true,
			allowCaseless : true
		}
	};

	// Some pre-defined groups of settings for convenience
	var CONVENIENCE_SETTINGS_NUMERIC = {
		"integer" : {
			allowPlus    : false,
			allowMinus   : true,
			allowThouSep : false,
			allowDecSep  : false
		},
		"positiveInteger" : {
			allowPlus    : false,
			allowMinus   : false,
			allowThouSep : false,
			allowDecSep  : false
		}
	};
	
	
	var BLACKLIST   = getBlacklistAscii() + getBlacklistNonAscii();
	var THOU_SEP    = ",";
	var DEC_SEP     = ".";
	var DIGITS      = getDigitsMap();
	var LATIN_CHARS = getLatinCharsSet();
	
	// Return the blacklisted special chars that are encodable using 7-bit ascii
	function getBlacklistAscii(){
		var blacklist = '!@#$%^&*()+=[]\\\';,/{}|":<>?~`.-_';
		blacklist += " "; // 'Space' is on the blacklist but can be enabled using the 'allowSpace' config entry
		return blacklist;
	}
	
	// Return the blacklisted special chars that are NOT encodable using 7-bit ascii
	// We want this .js file to be encoded using 7-bit ascii so it can reach the widest possible audience
	// Higher order chars must be escaped eg "\xAC"
	// Not too worried about comments containing higher order characters for now (let's wait and see if it becomes a problem)
	function getBlacklistNonAscii(){
		var blacklist = 
			  "\xAC"     // �
			+ "\u20AC"   // �
			+ "\xA3"     // �
			+ "\xA6"     // �
			;
		return blacklist;
	}
	
	// End Settings ////////////////////////////////////////////////////////
	
	
	// Implementation details go here ////////////////////////////////////////////////////////

	function setupEventHandlers($textboxes, trimFunction, settings) {

		$textboxes.each(function(){

			var $textbox = $(this);

			$textbox.bind("keyup change paste", function(e){

				var pastedText = "";

				if(e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData)
					pastedText = e.originalEvent.clipboardData.getData("text/plain")

				// setTimeout is necessary for handling the 'paste' event
				setTimeout(function(){
					trimTextbox($textbox, trimFunction, settings, pastedText);
				}, 0);
			});

			$textbox.bind("keypress", function(e){
				
				// Determine which key is pressed.
				// If it's a control key, then allow the event's default action to occur eg backspace, tab
				var charCode = !e.charCode ? e.which : e.charCode;
				if(isControlKey(charCode)
					|| e.ctrlKey
					|| e.metaKey ) // cmd on MacOS
					return;

				var newChar         = String.fromCharCode(charCode);

				// Determine if some text was selected / highlighted when the key was pressed
				var selectionObject = $textbox.selection();
				var start = selectionObject.start;
				var end   = selectionObject.end;

				var textBeforeKeypress  = $textbox.val();
				
				// The new char may be inserted:
				//  1) At the start
				//  2) In the middle
				//  3) At the end
				//  4) User highlights some text and then presses a key which would replace the highlighted text
				//
				// Here we build the string that would result after the keypress.
				// If the resulting string is invalid, we cancel the event.
				// Unfortunately, it isn't enough to just check if the new char is valid because some chars
				// are position sensitive eg the decimal point '.'' or the minus sign '-'' are only valid in certain positions.
				var potentialTextAfterKeypress = textBeforeKeypress.substring(0, start) + newChar + textBeforeKeypress.substring(end);
				var validatedText              = trimFunction(potentialTextAfterKeypress, settings);

				// If the keypress would cause the textbox to contain invalid characters, then cancel the keypress event
				if(validatedText != potentialTextAfterKeypress)
					e.preventDefault();
			});
		});

	}

	// Ensure the text is a valid number when focus leaves the textbox
	// This catches the case where a user enters '-' or '.' without entering any digits
	function numericField_Blur(inputBox, settings) {
		var fieldValueNumeric = parseFloat($(inputBox).val());
		var $inputBox = $(inputBox);

		if(isNaN(fieldValueNumeric)) {
			$inputBox.val("");
			return;
		}

		if(isNumeric(settings.min) && fieldValueNumeric < settings.min)
			$inputBox.val("");

		if(isNumeric(settings.max) && fieldValueNumeric > settings.max)
			$inputBox.val("");
	}

	function isNumeric(value) {
		return !isNaN(value);
	}

	function isControlKey(charCode) {

		if(charCode >= 32)
			return false;
		if(charCode == 10)
			return false;
		if(charCode == 13)
			return false;

		return true;
	}
	
	// One way to prevent a character being entered is to cancel the keypress event.
	// However, this gets messy when you have to deal with things like copy paste which isn't a keypress.
	// Which event gets fired first, keypress or keyup? What about IE6 etc etc?
	// Instead, it's easier to allow the 'bad' character to be entered and then to delete it immediately after.
	
	function trimTextbox($textBox, trimFunction, settings, pastedText){
		
		var inputString = $textBox.val();

		if(inputString == "" && pastedText.length > 0)
			inputString = pastedText;
		
		var outputString = trimFunction(inputString, settings);
		
		if(inputString == outputString)
			return;
		
		var caretPos = $textBox.alphanum_caret();
		
		$textBox.val(outputString);
		
		//Reset the caret position
		if(inputString.length ==(outputString.length + 1))
			$textBox.alphanum_caret(caretPos - 1);
		else
			$textBox.alphanum_caret(caretPos);
	}
	
	function getCombinedSettingsAlphaNum(settings, defaultSettings){
		if(typeof defaultSettings == "undefined")
			defaultSettings = DEFAULT_SETTINGS_ALPHANUM;
		var userSettings, combinedSettings = {};
		if(typeof settings === "string")
			userSettings = CONVENIENCE_SETTINGS_ALPHANUM[settings];
		else if(typeof settings == "undefined")
			userSettings = {};
		else
			userSettings = settings;
		
		$.extend(combinedSettings, defaultSettings, userSettings);
		
		if(typeof combinedSettings.blacklist == 'undefined')
			combinedSettings.blacklistSet = getBlacklistSet(combinedSettings.allow, combinedSettings.disallow);
		
		return combinedSettings;
	}
	
	function getCombinedSettingsNum(settings){
		var userSettings, combinedSettings = {};
		if(typeof settings === "string")
			userSettings = CONVENIENCE_SETTINGS_NUMERIC[settings];
		else if(typeof settings == "undefined")
			userSettings = {};
		else
			userSettings = settings;
		
		$.extend(combinedSettings, DEFAULT_SETTINGS_NUM, userSettings);
		
		return combinedSettings;
	}
	
	
	// This is the heart of the algorithm
	function alphanum_allowChar(validatedStringFragment, Char, settings){

		if(settings.maxLength && validatedStringFragment.length >= settings.maxLength)
			return false;

		if(settings.allow.indexOf(Char) >=0 )
			return true;
		
		if(settings.allowSpace && (Char == " "))
			return true;
			
		if(settings.blacklistSet.contains(Char))
			return false;
		
		if(!settings.allowNumeric && DIGITS[Char])
			return false;
			
		if(!settings.allowUpper && isUpper(Char))
			return false;
			
		if(!settings.allowLower && isLower(Char))
			return false;
			
		if(!settings.allowCaseless && isCaseless(Char))
			return false;
		
		if(!settings.allowLatin && LATIN_CHARS.contains(Char))
			return false;
		
		if(!settings.allowOtherCharSets){
			if(DIGITS[Char] || LATIN_CHARS.contains(Char))
				return true;
			else
				return false;
		}
		
		return true;
	}
	
	function numeric_allowChar(validatedStringFragment, Char, settings){

		if(DIGITS[Char]) {

			if(isMaxDigitsReached(validatedStringFragment, settings))
				return false;

			if(isMaxPreDecimalsReached(validatedStringFragment, settings))
				return false;

			if(isMaxDecimalsReached(validatedStringFragment, settings))
				return false;

			if(isGreaterThanMax(validatedStringFragment + Char, settings))
				return false;

			if(isLessThanMin(validatedStringFragment + Char, settings))
				return false;

			return true;
		}

		if(settings.allowPlus && Char == '+' && validatedStringFragment == '')
			return true;

		if(settings.allowMinus && Char == '-' && validatedStringFragment == '')
			return true;

		if(Char == THOU_SEP && settings.allowThouSep && allowThouSep(validatedStringFragment, Char))
			return true;

		if(Char == DEC_SEP) {
			// Only one decimal separator allowed
			if(validatedStringFragment.indexOf(DEC_SEP) >= 0)
				return false;
			if(settings.allowDecSep)
				return true;
		}
		
		return false;
	}

	function countDigits(string) {

		// Error handling, nulls etc
		string = string + "";

		// Count the digits
		return string.replace(/[^0-9]/g,"").length;
	}

	function isMaxDigitsReached(string, settings) {

		var maxDigits = settings.maxDigits;

		if(maxDigits == "" || isNaN(maxDigits))
			return false; // In this case, there is no maximum

		var numDigits = countDigits(string);

		if(numDigits >= maxDigits)
			return true;

		return false;
	}

	function isMaxDecimalsReached(string, settings) {

		var maxDecimalPlaces = settings.maxDecimalPlaces;

		if(maxDecimalPlaces == "" || isNaN(maxDecimalPlaces))
			return false; // In this case, there is no maximum

		var indexOfDecimalPoint = string.indexOf(DEC_SEP);

		if(indexOfDecimalPoint == -1)
			return false;

		var decimalSubstring = string.substring(indexOfDecimalPoint);
		var numDecimals = countDigits(decimalSubstring);

		if(numDecimals >= maxDecimalPlaces)
			return true;

		return false;
	}

	function isMaxPreDecimalsReached(string, settings) {

		var maxPreDecimalPlaces = settings.maxPreDecimalPlaces;

		if(maxPreDecimalPlaces == "" || isNaN(maxPreDecimalPlaces))
			return false; // In this case, there is no maximum

		var indexOfDecimalPoint = string.indexOf(DEC_SEP);

		if(indexOfDecimalPoint >= 0)
			return false;

		var numPreDecimalDigits = countDigits(string);

		if(numPreDecimalDigits >= maxPreDecimalPlaces)
			return true;

		return false;
	}

	function isGreaterThanMax(numericString, settings) {

		if(!settings.max || settings.max < 0)
			return false;

		var outputNumber = parseFloat(numericString);
		if(outputNumber > settings.max)
			return true;

		return false;
	}

	function isLessThanMin(numericString, settings) {

		if(!settings.min || settings.min > 0)
			return false;

		var outputNumber = parseFloat(numericString);
		if(outputNumber < settings.min)
			return true;

		return false;
	}
	
	/********************************
	 * Trims a string according to the settings provided
	 ********************************/
	function trimAlphaNum(inputString, settings){
		
		if(typeof inputString != "string")
			return inputString;
		
		var inChars = inputString.split("");
		var outChars = [];
		var i = 0;
		var Char;
		
		for(i=0; i<inChars.length; i++){
			Char = inChars[i];
			var validatedStringFragment = outChars.join("");
			if(alphanum_allowChar(validatedStringFragment, Char, settings))
				outChars.push(Char);
		}
		
		return outChars.join("");
	}
	
	function trimNum(inputString, settings){
		if(typeof inputString != "string")
			return inputString;
		
		var inChars = inputString.split("");
		var outChars = [];
		var i = 0;
		var Char;
		
		for(i=0; i<inChars.length; i++){
			Char = inChars[i];
			var validatedStringFragment = outChars.join("");
			if(numeric_allowChar(validatedStringFragment, Char, settings))
				outChars.push(Char);
		}
		
		return outChars.join("");
	}
	
	function removeUpperCase(inputString){
		var charArray = inputString.split('');
		var i = 0;
		var outputArray = [];
		var Char;
		
		for(i=0; i<charArray.length; i++){
			Char = charArray[i];
		}
	}
	
	function removeLowerCase(inputString){
		
	}
	
	function isUpper(Char){
		var upper = Char.toUpperCase();
		var lower = Char.toLowerCase();
		
		if( (Char == upper) && (upper != lower))
			return true;
		else
			return false;
	}
	
	function isLower(Char){
		var upper = Char.toUpperCase();
		var lower = Char.toLowerCase();
		
		if( (Char == lower) && (upper != lower))
			return true;
		else
			return false;
	}
	
	function isCaseless(Char){
		if(Char.toUpperCase() == Char.toLowerCase())
			return true;
		else
			return false;
	}
	
	function getBlacklistSet(allow, disallow){
		
		var setOfBadChars  = new Set(BLACKLIST + disallow);
		var setOfGoodChars = new Set(allow);
		
		var blacklistSet   = setOfBadChars.subtract(setOfGoodChars);
		
		return blacklistSet;
	}
	
	function getDigitsMap(){
		var array = "0123456789".split("");
		var map = {};
		var i = 0;
		var digit;
		
		for(i=0; i<array.length; i++){
			digit = array[i];
			map[digit] = true;
		}
		
		return map;
	}
	
	function getLatinCharsSet(){
		var lower = "abcdefghijklmnopqrstuvwxyz";
		var upper = lower.toUpperCase();
		var azAZ = new Set(lower + upper);
		
		return azAZ;
	}

	function allowThouSep(currentString, Char) {

		// Can't start with a THOU_SEP
		if(currentString.length == 0)
			return false;

		// Can't have a THOU_SEP anywhere after a DEC_SEP
		var posOfDecSep = currentString.indexOf(DEC_SEP);
		if(posOfDecSep >= 0)
			return false;

		var posOfFirstThouSep       = currentString.indexOf(THOU_SEP);

		// Check if this is the first occurrence of a THOU_SEP
		if(posOfFirstThouSep < 0)
			return true;

		var posOfLastThouSep        = currentString.lastIndexOf(THOU_SEP);
		var charsSinceLastThouSep   = currentString.length - posOfLastThouSep - 1;

		// Check if there has been 3 digits since the last THOU_SEP
		if(charsSinceLastThouSep < 3)
			return false;

		var digitsSinceFirstThouSep = countDigits(currentString.substring(posOfFirstThouSep));

		// Check if there has been a multiple of 3 digits since the first THOU_SEP
		if((digitsSinceFirstThouSep % 3) > 0)
			return false;

		return true;
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	// Implementation of a Set
	////////////////////////////////////////////////////////////////////////////////////
	function Set(elems){
		if(typeof elems == "string")
			this.map = stringToMap(elems);
		else
			this.map = {};
	}
	
	Set.prototype.add = function(set){
	
		var newSet = this.clone();
		
		for(var key in set.map)
			newSet.map[key] = true;
		
		return newSet;
	}
	
	Set.prototype.subtract = function(set){
		
		var newSet = this.clone();
		
		for(var key in set.map)
			delete newSet.map[key];
			
		return newSet;
	}
	
	Set.prototype.contains = function(key){
		if(this.map[key])
			return true;
		else
			return false;
	}
	
	Set.prototype.clone = function(){
		var newSet = new Set();
		
		for(var key in this.map)
			newSet.map[key] = true;
		
		return newSet;
	}
	////////////////////////////////////////////////////////////////////////////////////
	
	function stringToMap(string){
		var map = {};
		var array = string.split("");
		var i=0;
		var Char;
		
		for(i=0; i<array.length; i++){
			Char = array[i];
			map[Char] = true;
		}
		
		return map;
	}
	
	// Backdoor for testing
	$.fn.alphanum.backdoorAlphaNum = function(inputString, settings){
		var combinedSettings = getCombinedSettingsAlphaNum(settings);
		
		return trimAlphaNum(inputString, combinedSettings);
	};
	
	$.fn.alphanum.backdoorNumeric = function(inputString, settings){
		var combinedSettings = getCombinedSettingsNum(settings);
		
		return trimNum(inputString, combinedSettings);
	};

	$.fn.alphanum.setNumericSeparators = function(settings) {

		if(settings.thousandsSeparator.length != 1)
			return;

		if(settings.decimalSeparator.length != 1)
			return;

		THOU_SEP = settings.thousandsSeparator;
		DEC_SEP = settings.decimalSeparator;
	}

})( jQuery );


//Include the 3rd party lib: jquery.caret.js


// Set caret position easily in jQuery
// Written by and Copyright of Luke Morton, 2011
// Licensed under MIT
(function ($) {
	// Behind the scenes method deals with browser
	// idiosyncrasies and such
	function caretTo(el, index) {
		if (el.createTextRange) { 
			var range = el.createTextRange(); 
			range.move("character", index); 
			range.select(); 
		} else if (el.selectionStart != null) { 
			el.focus(); 
			el.setSelectionRange(index, index); 
		}
	};
	
	// Another behind the scenes that collects the
	// current caret position for an element
	
	// TODO: Get working with Opera
	function caretPos(el) {
		if ("selection" in document) {
			var range = el.createTextRange();
			try {
				range.setEndPoint("EndToStart", document.selection.createRange());
			} catch (e) {
				// Catch IE failure here, return 0 like
				// other browsers
				return 0;
			}
			return range.text.length;
		} else if (el.selectionStart != null) {
			return el.selectionStart;
		}
	};

	// The following methods are queued under fx for more
	// flexibility when combining with $.fn.delay() and
	// jQuery effects.

	// Set caret to a particular index
	$.fn.alphanum_caret = function (index, offset) {
		if (typeof(index) === "undefined") {
			return caretPos(this.get(0));
		}
		
		return this.queue(function (next) {
			if (isNaN(index)) {
				var i = $(this).val().indexOf(index);
				
				if (offset === true) {
					i += index.length;
				} else if (typeof(offset) !== "undefined") {
					i += offset;
				}
				
				caretTo(this, i);
			} else {
				caretTo(this, index);
			}
			
			next();
		});
	};
}(jQuery));

/**********************************************************
* Selection Library
* Used to determine what text is highlighted in the textbox before a key is pressed.
* http://donejs.com/docs.html#!jQuery.fn.selection
* https://github.com/jupiterjs/jquerymx/blob/master/dom/selection/selection.js
***********************************************************/
(function(e){var t=function(e){return e.replace(/([a-z])([a-z]+)/gi,function(e,t,n){return t+n.toLowerCase()}).replace(/_/g,"")},n=function(e){return e.replace(/^([a-z]+)_TO_([a-z]+)/i,function(e,t,n){return n+"_TO_"+t})},r=function(e){return e?e.ownerDocument.defaultView||e.ownerDocument.parentWindow:window},i=function(t,n){var r=e.Range.current(t).clone(),i=e.Range(t).select(t);if(!r.overlaps(i)){return null}if(r.compare("START_TO_START",i)<1){startPos=0;r.move("START_TO_START",i)}else{fromElementToCurrent=i.clone();fromElementToCurrent.move("END_TO_START",r);startPos=fromElementToCurrent.toString().length}if(r.compare("END_TO_END",i)>=0){endPos=i.toString().length}else{endPos=startPos+r.toString().length}return{start:startPos,end:endPos}},s=function(t){var n=r(t);if(t.selectionStart!==undefined){if(document.activeElement&&document.activeElement!=t&&t.selectionStart==t.selectionEnd&&t.selectionStart==0){return{start:t.value.length,end:t.value.length}}return{start:t.selectionStart,end:t.selectionEnd}}else if(n.getSelection){return i(t,n)}else{try{if(t.nodeName.toLowerCase()=="input"){var s=r(t).document.selection.createRange(),o=t.createTextRange();o.setEndPoint("EndToStart",s);var u=o.text.length;return{start:u,end:u+s.text.length}}else{var a=i(t,n);if(!a){return a}var f=e.Range.current().clone(),l=f.clone().collapse().range,c=f.clone().collapse(false).range;l.moveStart("character",-1);c.moveStart("character",-1);if(a.startPos!=0&&l.text==""){a.startPos+=2}if(a.endPos!=0&&c.text==""){a.endPos+=2}return a}}catch(h){return{start:t.value.length,end:t.value.length}}}},o=function(e,t,n){var i=r(e);if(e.setSelectionRange){if(n===undefined){e.focus();e.setSelectionRange(t,t)}else{e.select();e.selectionStart=t;e.selectionEnd=n}}else if(e.createTextRange){var s=e.createTextRange();s.moveStart("character",t);n=n||t;s.moveEnd("character",n-e.value.length);s.select()}else if(i.getSelection){var o=i.document,u=i.getSelection(),f=o.createRange(),l=[t,n!==undefined?n:t];a([e],l);f.setStart(l[0].el,l[0].count);f.setEnd(l[1].el,l[1].count);u.removeAllRanges();u.addRange(f)}else if(i.document.body.createTextRange){var f=document.body.createTextRange();f.moveToElementText(e);f.collapse();f.moveStart("character",t);f.moveEnd("character",n!==undefined?n:t);f.select()}},u=function(e,t,n,r){if(typeof n[0]==="number"&&n[0]<t){n[0]={el:r,count:n[0]-e}}if(typeof n[1]==="number"&&n[1]<=t){n[1]={el:r,count:n[1]-e};}},a=function(e,t,n){var r,i;n=n||0;for(var s=0;e[s];s++){r=e[s];if(r.nodeType===3||r.nodeType===4){i=n;n+=r.nodeValue.length;u(i,n,t,r)}else if(r.nodeType!==8){n=a(r.childNodes,t,n)}}return n};jQuery.fn.selection=function(e,t){if(e!==undefined){return this.each(function(){o(this,e,t)})}else{return s(this[0])}};e.fn.selection.getCharElement=a})(jQuery);/**
 * jQuery Select2 Sortable
 * - enable select2 to be sortable via normal select element
 * 
 * author      : Vafour
 * inspired by : jQuery Chosen Sortable (https://github.com/mrhenry/jquery-chosen-sortable)
 * License     : GPL
 */

(function($){
	$.fn.extend({
		select2SortableOrder: function(){
			var $this = this.filter('[multiple]');

			$this.each(function(){
				var $select  = $(this);

				// skip elements not select2-ed
				if(typeof($select.data('select2')) !== 'object'){
					return false;
				}

				var $select2 = $select.siblings('.select2-container'),
				    unselected = [],
				    sorted;

				$select.find('option').each(function(){
					!this.selected && unselected.push(this);
				});

				sorted = $($select2.find('.select2-choices li[class!="select2-search-field"]').map( function() {
					if (!this) {
						return undefined;
					}
					var id = $(this).data('select2Data').id;
					return $select.find('option[value="' + id + '"]')[0];
				}));

				sorted.push.apply(sorted, unselected);
				$select.children().remove();
				$select.append(sorted);
			});

			return $this;
		},
		select2Sortable: function(){
			var args         = Array.prototype.slice.call(arguments, 0);
			    $this        = this.filter('[multiple]'),
			    validMethods = ['destroy'];

			if(args.length === 0 || typeof(args[0]) === 'object')
			{
				var defaultOptions = {
					bindOrder       : 'formSubmit', // or sortableStop
					sortableOptions : {
						placeholder : 'ui-state-highlight',
						items       : 'li:not(.select2-search-field)',
						tolerance   : 'pointer'
					}
				};
				var options = $.extend(defaultOptions, args[0]);

				// Init select2 only if not already initialized to prevent select2 configuration loss
				if(typeof($this.data('select2')) !== 'object'){
					$this.select2();
				}

				$this.each(function(){
					var $select  = $(this),
					    $select2choices = $select.siblings('.select2-container').find('.select2-choices');

					// Init jQuery UI Sortable
					$select2choices.sortable(options.sortableOptions);

					switch(options.bindOrder){
						case 'sortableStop':
							// apply options ordering in sortstop event
							$select2choices.on("sortstop.select2sortable", function( event, ui ) {
								$select.select2SortableOrder();
							});
							$select.on('change', function(e){
								$(this).select2SortableOrder();
							});
							break;
						default:
							// apply options ordering in form submit
							$select.closest('form').unbind('submit.select2sortable').on('submit.select2sortable', function(){
								$select.select2SortableOrder();
							});
					}

				});
			}
			else if(typeof(args[0] === 'string'))
			{
				if($.inArray(args[0], validMethods) == -1)
				{
					throw "Unknown method: " + args[0];
				}
				if(args[0] === 'destroy')
				{
					$this.select2SortableDestroy();
				}
			}
			return $this;
		},
		select2SortableDestroy: function(){
			var $this = this.filter('[multiple]');
			$this.each(function(){
				var $select         = $(this),
				    $select2choices = $select.parent().find('.select2-choices');

				// unbind form submit event
				$select.closest('form').unbind('submit.select2sortable');

				// unbind sortstop event
				$select2choices.unbind("sortstop.select2sortable");

				// destroy select2Sortable
				$select2choices.sortable('destroy');
			});
			return $this;
		}
	});
}(jQuery));;/*
 * jQuery MiniColors: A tiny color picker built on jQuery
 *
 * Copyright Cory LaViska for A Beautiful Site, LLC. (http://www.abeautifulsite.net/)
 *
 * Licensed under the MIT license: http://opensource.org/licenses/MIT
 *
 */
if(jQuery) (function($) {
	
	// Defaults
	$.minicolors = {
		defaults: {
			animationSpeed: 50,
			animationEasing: 'swing',
			change: null,
			changeDelay: 0,
			control: 'hue',
			defaultValue: '',
			hide: null,
			hideSpeed: 100,
			inline: false,
			letterCase: 'lowercase',
			opacity: false,
			position: 'bottom left',
			show: null,
			showSpeed: 100,
			theme: 'default'
		}
	};
	
	// Public methods
	$.extend($.fn, {
		minicolors: function(method, data) {
			
			switch(method) {
				
				// Destroy the control
				case 'destroy':
					$(this).each( function() {
						destroy($(this));
					});
					return $(this);
				
				// Hide the color picker
				case 'hide':
					hide();
					return $(this);
				
				// Get/set opacity
				case 'opacity':
					// Getter
					if( data === undefined ) {
						// Getter
						return $(this).attr('data-opacity');
					} else {
						// Setter
						$(this).each( function() {
							updateFromInput($(this).attr('data-opacity', data));
						});
					}
					return $(this);
				
				// Get an RGB(A) object based on the current color/opacity
				case 'rgbObject':
					return rgbObject($(this), method === 'rgbaObject');
				
				// Get an RGB(A) string based on the current color/opacity
				case 'rgbString':
				case 'rgbaString':
					return rgbString($(this), method === 'rgbaString');
				
				// Get/set settings on the fly
				case 'settings':
					if( data === undefined ) {
						return $(this).data('minicolors-settings');
					} else {
						// Setter
						$(this).each( function() {
							var settings = $(this).data('minicolors-settings') || {};
							destroy($(this));
							$(this).minicolors($.extend(true, settings, data));
						});
					}
					return $(this);
				
				// Show the color picker
				case 'show':
					show( $(this).eq(0) );
					return $(this);
				
				// Get/set the hex color value
				case 'value':
					if( data === undefined ) {
						// Getter
						return $(this).val();
					} else {
						// Setter
						$(this).each( function() {
							updateFromInput($(this).val(data));
						});
					}
					return $(this);
				
				// Initializes the control
				default:
					if( method !== 'create' ) data = method;
					$(this).each( function() {
						init($(this), data);
					});
					return $(this);
				
			}
			
		}
	});
	
	// Initialize input elements
	function init(input, settings) {
		
		var minicolors = $('<div class="minicolors" />'),
			defaults = $.minicolors.defaults;
		
		// Do nothing if already initialized
		if( input.data('minicolors-initialized') ) return;
		
		// Handle settings
		settings = $.extend(true, {}, defaults, settings);
		
		// The wrapper
		minicolors
			.addClass('minicolors-theme-' + settings.theme)
			.toggleClass('minicolors-with-opacity', settings.opacity);
		
		// Custom positioning
		if( settings.position !== undefined ) {
			$.each(settings.position.split(' '), function() {
				minicolors.addClass('minicolors-position-' + this);
			});
		}
		
		// The input
		input
			.addClass('minicolors-input')
			.data('minicolors-initialized', false)
			.data('minicolors-settings', settings)
			.prop('size', 7)
			.wrap(minicolors)
			.after(
				'<div class="minicolors-panel minicolors-slider-' + settings.control + '">' + 
					'<div class="minicolors-slider">' + 
						'<div class="minicolors-picker"></div>' +
					'</div>' + 
					'<div class="minicolors-opacity-slider">' + 
						'<div class="minicolors-picker"></div>' +
					'</div>' +
					'<div class="minicolors-grid">' +
						'<div class="minicolors-grid-inner"></div>' +
						'<div class="minicolors-picker"><div></div></div>' +
					'</div>' +
				'</div>'
			);
		
		// The swatch
		if( !settings.inline ) {
			input.after('<span class="minicolors-swatch"><span class="minicolors-swatch-color"></span></span>');
			input.next('.minicolors-swatch').on('click', function(event) {
				event.preventDefault();
				input.focus();
			});
		}
		
		// Prevent text selection in IE
		input.parent().find('.minicolors-panel').on('selectstart', function() { return false; }).end();
		
		// Inline controls
		if( settings.inline ) input.parent().addClass('minicolors-inline');
		
		updateFromInput(input, false);
		
		input.data('minicolors-initialized', true);
		
	}
	
	// Returns the input back to its original state
	function destroy(input) {
		
		var minicolors = input.parent();
		
		// Revert the input element
		input
			.removeData('minicolors-initialized')
			.removeData('minicolors-settings')
			.removeProp('size')
			.removeClass('minicolors-input');
		
		// Remove the wrap and destroy whatever remains
		minicolors.before(input).remove();
		
	}
	
	// Shows the specified dropdown panel
	function show(input) {
		
		var minicolors = input.parent(),
			panel = minicolors.find('.minicolors-panel'),
			settings = input.data('minicolors-settings');
		
		// Do nothing if uninitialized, disabled, inline, or already open
		if( !input.data('minicolors-initialized') || 
			input.prop('disabled') || 
			minicolors.hasClass('minicolors-inline') || 
			minicolors.hasClass('minicolors-focus')
		) return;
		
		hide();
		
		minicolors.addClass('minicolors-focus');
		panel
			.stop(true, true)
			.fadeIn(settings.showSpeed, function() {
				if( settings.show ) settings.show.call(input.get(0));
			});
		
	}
	
	// Hides all dropdown panels
	function hide() {
		
		$('.minicolors-input').each( function() {
			
			var input = $(this),
				settings = input.data('minicolors-settings'),
				minicolors = input.parent();
			
			// Don't hide inline controls
			if( settings.inline ) return;
			
			minicolors.find('.minicolors-panel').fadeOut(settings.hideSpeed, function() {
				if(minicolors.hasClass('minicolors-focus')) {
					if( settings.hide ) settings.hide.call(input.get(0));
				}
				minicolors.removeClass('minicolors-focus');
			});			
						
		});
	}
	
	// Moves the selected picker
	function move(target, event, animate) {
		
		var input = target.parents('.minicolors').find('.minicolors-input'),
			settings = input.data('minicolors-settings'),
			picker = target.find('[class$=-picker]'),
			offsetX = target.offset().left,
			offsetY = target.offset().top,
			x = Math.round(event.pageX - offsetX),
			y = Math.round(event.pageY - offsetY),
			duration = animate ? settings.animationSpeed : 0,
			wx, wy, r, phi;
			
		
		// Touch support
		if( event.originalEvent.changedTouches ) {
			x = event.originalEvent.changedTouches[0].pageX - offsetX;
			y = event.originalEvent.changedTouches[0].pageY - offsetY;
		}
		
		// Constrain picker to its container
		if( x < 0 ) x = 0;
		if( y < 0 ) y = 0;
		if( x > target.width() ) x = target.width();
		if( y > target.height() ) y = target.height();
		
		// Constrain color wheel values to the wheel
		if( target.parent().is('.minicolors-slider-wheel') && picker.parent().is('.minicolors-grid') ) {
			wx = 75 - x;
			wy = 75 - y;
			r = Math.sqrt(wx * wx + wy * wy);
			phi = Math.atan2(wy, wx);
			if( phi < 0 ) phi += Math.PI * 2;
			if( r > 75 ) {
				r = 75;
				x = 75 - (75 * Math.cos(phi));
				y = 75 - (75 * Math.sin(phi));
			}
			x = Math.round(x);
			y = Math.round(y);
		}
		
		// Move the picker
		if( target.is('.minicolors-grid') ) {
			picker
				.stop(true)
				.animate({
					top: y + 'px',
					left: x + 'px'
				}, duration, settings.animationEasing, function() {
					updateFromControl(input, target);
				});
		} else {
			picker
				.stop(true)
				.animate({
					top: y + 'px'
				}, duration, settings.animationEasing, function() {
					updateFromControl(input, target);
				});
		}
		
	}
	
	// Sets the input based on the color picker values
	function updateFromControl(input, target) {
		
		function getCoords(picker, container) {
			
			var left, top;
			if( !picker.length || !container ) return null;
			left = picker.offset().left;
			top = picker.offset().top;
			
			return {
				x: left - container.offset().left + (picker.outerWidth() / 2),
				y: top - container.offset().top + (picker.outerHeight() / 2)
			};
			
		}
		
		var hue, saturation, brightness, x, y, r, phi,
			
			hex = input.val(),
			opacity = input.attr('data-opacity'),
			
			// Helpful references
			minicolors = input.parent(),
			settings = input.data('minicolors-settings'),
			swatch = minicolors.find('.minicolors-swatch'),
			
			// Panel objects
			grid = minicolors.find('.minicolors-grid'),
			slider = minicolors.find('.minicolors-slider'),
			opacitySlider = minicolors.find('.minicolors-opacity-slider'),
			
			// Picker objects
			gridPicker = grid.find('[class$=-picker]'),
			sliderPicker = slider.find('[class$=-picker]'),
			opacityPicker = opacitySlider.find('[class$=-picker]'),
			
			// Picker positions
			gridPos = getCoords(gridPicker, grid),
			sliderPos = getCoords(sliderPicker, slider),
			opacityPos = getCoords(opacityPicker, opacitySlider);
		
		// Handle colors
		if( target.is('.minicolors-grid, .minicolors-slider') ) {
			
			// Determine HSB values
			switch(settings.control) {
				
				case 'wheel':
					// Calculate hue, saturation, and brightness
					x = (grid.width() / 2) - gridPos.x;
					y = (grid.height() / 2) - gridPos.y;
					r = Math.sqrt(x * x + y * y);
					phi = Math.atan2(y, x);
					if( phi < 0 ) phi += Math.PI * 2;
					if( r > 75 ) {
						r = 75;
						gridPos.x = 69 - (75 * Math.cos(phi));
						gridPos.y = 69 - (75 * Math.sin(phi));
					}
					saturation = keepWithin(r / 0.75, 0, 100);
					hue = keepWithin(phi * 180 / Math.PI, 0, 360);
					brightness = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);
					hex = hsb2hex({
						h: hue,
						s: saturation,
						b: brightness
					});
					
					// Update UI
					slider.css('backgroundColor', hsb2hex({ h: hue, s: saturation, b: 100 }));
					break;
				
				case 'saturation':
					// Calculate hue, saturation, and brightness
					hue = keepWithin(parseInt(gridPos.x * (360 / grid.width()), 10), 0, 360);
					saturation = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);
					brightness = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);
					hex = hsb2hex({
						h: hue,
						s: saturation,
						b: brightness
					});
					
					// Update UI
					slider.css('backgroundColor', hsb2hex({ h: hue, s: 100, b: brightness }));
					minicolors.find('.minicolors-grid-inner').css('opacity', saturation / 100);
					break;
				
				case 'brightness':
					// Calculate hue, saturation, and brightness
					hue = keepWithin(parseInt(gridPos.x * (360 / grid.width()), 10), 0, 360);
					saturation = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);
					brightness = keepWithin(100 - Math.floor(sliderPos.y * (100 / slider.height())), 0, 100);
					hex = hsb2hex({
						h: hue,
						s: saturation,
						b: brightness
					});
					
					// Update UI
					slider.css('backgroundColor', hsb2hex({ h: hue, s: saturation, b: 100 }));
					minicolors.find('.minicolors-grid-inner').css('opacity', 1 - (brightness / 100));
					break;
				
				default:
					// Calculate hue, saturation, and brightness
					hue = keepWithin(360 - parseInt(sliderPos.y * (360 / slider.height()), 10), 0, 360);
					saturation = keepWithin(Math.floor(gridPos.x * (100 / grid.width())), 0, 100);
					brightness = keepWithin(100 - Math.floor(gridPos.y * (100 / grid.height())), 0, 100);
					hex = hsb2hex({
						h: hue,
						s: saturation,
						b: brightness
					});
					
					// Update UI
					grid.css('backgroundColor', hsb2hex({ h: hue, s: 100, b: 100 }));
					break;
				
			}
		
			// Adjust case
			input.val( convertCase(hex, settings.letterCase) );
			
		}
		
		// Handle opacity
		if( target.is('.minicolors-opacity-slider') ) {
			if( settings.opacity ) {
				opacity = parseFloat(1 - (opacityPos.y / opacitySlider.height())).toFixed(2);
			} else {
				opacity = 1;
			}
			if( settings.opacity ) input.attr('data-opacity', opacity);
		}
		
		// Set swatch color
		swatch.find('SPAN').css({
			backgroundColor: hex,
			opacity: opacity
		});
		
		// Handle change event
		doChange(input, hex, opacity);
		
	}
	
	// Sets the color picker values from the input
	function updateFromInput(input, preserveInputValue) {
		
		var hex,
			hsb,
			opacity,
			x, y, r, phi,
			
			// Helpful references
			minicolors = input.parent(),
			settings = input.data('minicolors-settings'),
			swatch = minicolors.find('.minicolors-swatch'),
			
			// Panel objects
			grid = minicolors.find('.minicolors-grid'),
			slider = minicolors.find('.minicolors-slider'),
			opacitySlider = minicolors.find('.minicolors-opacity-slider'),
			
			// Picker objects
			gridPicker = grid.find('[class$=-picker]'),
			sliderPicker = slider.find('[class$=-picker]'),
			opacityPicker = opacitySlider.find('[class$=-picker]');
		
		// Determine hex/HSB values
		hex = convertCase(parseHex(input.val(), true), settings.letterCase);
		if( !hex ){
			hex = convertCase(parseHex(settings.defaultValue, true), settings.letterCase);
		}
		hsb = hex2hsb(hex);
		
		// Update input value
		if( !preserveInputValue ) input.val(hex);
		
		// Determine opacity value
		if( settings.opacity ) {
			// Get from data-opacity attribute and keep within 0-1 range
			opacity = input.attr('data-opacity') === '' ? 1 : keepWithin(parseFloat(input.attr('data-opacity')).toFixed(2), 0, 1);
			if( isNaN(opacity) ) opacity = 1;
			input.attr('data-opacity', opacity);
			swatch.find('SPAN').css('opacity', opacity);
			
			// Set opacity picker position
			y = keepWithin(opacitySlider.height() - (opacitySlider.height() * opacity), 0, opacitySlider.height());
			opacityPicker.css('top', y + 'px');
		}
		
		// Update swatch
		swatch.find('SPAN').css('backgroundColor', hex);
		
		// Determine picker locations
		switch(settings.control) {
			
			case 'wheel':
				// Set grid position
				r = keepWithin(Math.ceil(hsb.s * 0.75), 0, grid.height() / 2);
				phi = hsb.h * Math.PI / 180;
				x = keepWithin(75 - Math.cos(phi) * r, 0, grid.width());
				y = keepWithin(75 - Math.sin(phi) * r, 0, grid.height());
				gridPicker.css({
					top: y + 'px',
					left: x + 'px'
				});
				
				// Set slider position
				y = 150 - (hsb.b / (100 / grid.height()));
				if( hex === '' ) y = 0;
				sliderPicker.css('top', y + 'px');
				
				// Update panel color
				slider.css('backgroundColor', hsb2hex({ h: hsb.h, s: hsb.s, b: 100 }));
				break;
			
			case 'saturation':
				// Set grid position
				x = keepWithin((5 * hsb.h) / 12, 0, 150);
				y = keepWithin(grid.height() - Math.ceil(hsb.b / (100 / grid.height())), 0, grid.height());
				gridPicker.css({
					top: y + 'px',
					left: x + 'px'
				});				
				
				// Set slider position
				y = keepWithin(slider.height() - (hsb.s * (slider.height() / 100)), 0, slider.height());
				sliderPicker.css('top', y + 'px');
				
				// Update UI
				slider.css('backgroundColor', hsb2hex({ h: hsb.h, s: 100, b: hsb.b }));
				minicolors.find('.minicolors-grid-inner').css('opacity', hsb.s / 100);
				break;
			
			case 'brightness':
				// Set grid position
				x = keepWithin((5 * hsb.h) / 12, 0, 150);
				y = keepWithin(grid.height() - Math.ceil(hsb.s / (100 / grid.height())), 0, grid.height());
				gridPicker.css({
					top: y + 'px',
					left: x + 'px'
				});				
				
				// Set slider position
				y = keepWithin(slider.height() - (hsb.b * (slider.height() / 100)), 0, slider.height());
				sliderPicker.css('top', y + 'px');
				
				// Update UI
				slider.css('backgroundColor', hsb2hex({ h: hsb.h, s: hsb.s, b: 100 }));
				minicolors.find('.minicolors-grid-inner').css('opacity', 1 - (hsb.b / 100));
				break;
			
			default:
				// Set grid position
				x = keepWithin(Math.ceil(hsb.s / (100 / grid.width())), 0, grid.width());
				y = keepWithin(grid.height() - Math.ceil(hsb.b / (100 / grid.height())), 0, grid.height());
				gridPicker.css({
					top: y + 'px',
					left: x + 'px'
				});
				
				// Set slider position
				y = keepWithin(slider.height() - (hsb.h / (360 / slider.height())), 0, slider.height());
				sliderPicker.css('top', y + 'px');
				
				// Update panel color
				grid.css('backgroundColor', hsb2hex({ h: hsb.h, s: 100, b: 100 }));
				break;
				
		}
		
		// Fire change event, but only if minicolors is fully initialized
		if( input.data('minicolors-initialized') ) {
			doChange(input, hex, opacity);
		}
		
	}
	
	// Runs the change and changeDelay callbacks
	function doChange(input, hex, opacity) {
		
		var settings = input.data('minicolors-settings'),
			lastChange = input.data('minicolors-lastChange');
		
		// Only run if it actually changed
		if( !lastChange || lastChange.hex !== hex || lastChange.opacity !== opacity ) {
			
			// Remember last-changed value
			input.data('minicolors-lastChange', {
				hex: hex,
				opacity: opacity
			});
			
			// Fire change event
			if( settings.change ) {
				if( settings.changeDelay ) {
					// Call after a delay
					clearTimeout(input.data('minicolors-changeTimeout'));
					input.data('minicolors-changeTimeout', setTimeout( function() {
						settings.change.call(input.get(0), hex, opacity);
					}, settings.changeDelay));
				} else {
					// Call immediately
					settings.change.call(input.get(0), hex, opacity);
				}
			}
			input.trigger('change').trigger('input');
		}
	
	}
	
	// Generates an RGB(A) object based on the input's value
	function rgbObject(input) {
		var hex = parseHex($(input).val(), true),
			rgb = hex2rgb(hex),
			opacity = $(input).attr('data-opacity');
		if( !rgb ) return null;
		if( opacity !== undefined ) $.extend(rgb, { a: parseFloat(opacity) });
		return rgb;
	}
	
	// Genearates an RGB(A) string based on the input's value
	function rgbString(input, alpha) {
		var hex = parseHex($(input).val(), true),
			rgb = hex2rgb(hex),
			opacity = $(input).attr('data-opacity');
		if( !rgb ) return null;
		if( opacity === undefined ) opacity = 1;
		if( alpha ) {
			return 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + parseFloat(opacity) + ')';
		} else {
			return 'rgb(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ')';
		}
	}
	
	// Converts to the letter case specified in settings
	function convertCase(string, letterCase) {
		return letterCase === 'uppercase' ? string.toUpperCase() : string.toLowerCase();
	}
	
	// Parses a string and returns a valid hex string when possible
	function parseHex(string, expand) {
		string = string.replace(/[^A-F0-9]/ig, '');
		if( string.length !== 3 && string.length !== 6 ) return '';
		if( string.length === 3 && expand ) {
			string = string[0] + string[0] + string[1] + string[1] + string[2] + string[2];
		}
		return '#' + string;
	}
	
	// Keeps value within min and max
	function keepWithin(value, min, max) {
		if( value < min ) value = min;
		if( value > max ) value = max;
		return value;
	}
	
	// Converts an HSB object to an RGB object
	function hsb2rgb(hsb) {
		var rgb = {};
		var h = Math.round(hsb.h);
		var s = Math.round(hsb.s * 255 / 100);
		var v = Math.round(hsb.b * 255 / 100);
		if(s === 0) {
			rgb.r = rgb.g = rgb.b = v;
		} else {
			var t1 = v;
			var t2 = (255 - s) * v / 255;
			var t3 = (t1 - t2) * (h % 60) / 60;
			if( h === 360 ) h = 0;
			if( h < 60 ) { rgb.r = t1; rgb.b = t2; rgb.g = t2 + t3; }
			else if( h < 120 ) {rgb.g = t1; rgb.b = t2; rgb.r = t1 - t3; }
			else if( h < 180 ) {rgb.g = t1; rgb.r = t2; rgb.b = t2 + t3; }
			else if( h < 240 ) {rgb.b = t1; rgb.r = t2; rgb.g = t1 - t3; }
			else if( h < 300 ) {rgb.b = t1; rgb.g = t2; rgb.r = t2 + t3; }
			else if( h < 360 ) {rgb.r = t1; rgb.g = t2; rgb.b = t1 - t3; }
			else { rgb.r = 0; rgb.g = 0; rgb.b = 0; }
		}
		return {
			r: Math.round(rgb.r),
			g: Math.round(rgb.g),
			b: Math.round(rgb.b)
		};
	}
	
	// Converts an RGB object to a hex string
	function rgb2hex(rgb) {
		var hex = [
			rgb.r.toString(16),
			rgb.g.toString(16),
			rgb.b.toString(16)
		];
		$.each(hex, function(nr, val) {
			if (val.length === 1) hex[nr] = '0' + val;
		});
		return '#' + hex.join('');
	}
	
	// Converts an HSB object to a hex string
	function hsb2hex(hsb) {
		return rgb2hex(hsb2rgb(hsb));
	}
	
	// Converts a hex string to an HSB object
	function hex2hsb(hex) {
		var hsb = rgb2hsb(hex2rgb(hex));
		if( hsb.s === 0 ) hsb.h = 360;
		return hsb;
	}
	
	// Converts an RGB object to an HSB object
	function rgb2hsb(rgb) {
		var hsb = { h: 0, s: 0, b: 0 };
		var min = Math.min(rgb.r, rgb.g, rgb.b);
		var max = Math.max(rgb.r, rgb.g, rgb.b);
		var delta = max - min;
		hsb.b = max;
		hsb.s = max !== 0 ? 255 * delta / max : 0;
		if( hsb.s !== 0 ) {
			if( rgb.r === max ) {
				hsb.h = (rgb.g - rgb.b) / delta;
			} else if( rgb.g === max ) {
				hsb.h = 2 + (rgb.b - rgb.r) / delta;
			} else {
				hsb.h = 4 + (rgb.r - rgb.g) / delta;
			}
		} else {
			hsb.h = -1;
		}
		hsb.h *= 60;
		if( hsb.h < 0 ) {
			hsb.h += 360;
		}
		hsb.s *= 100/255;
		hsb.b *= 100/255;
		return hsb;
	}
	
	// Converts a hex string to an RGB object
	function hex2rgb(hex) {
		hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
		return {
			r: hex >> 16,
			g: (hex & 0x00FF00) >> 8,
			b: (hex & 0x0000FF)
		};
	}
	
	// Handle events
	$(document)
		// Hide on clicks outside of the control
		.on('mousedown.minicolors touchstart.minicolors', function(event) {
			if( !$(event.target).parents().add(event.target).hasClass('minicolors') ) {
				hide();
			}
		})
		// Start moving
		.on('mousedown.minicolors touchstart.minicolors', '.minicolors-grid, .minicolors-slider, .minicolors-opacity-slider', function(event) {
			var target = $(this);
			event.preventDefault();
			$(document).data('minicolors-target', target);
			move(target, event, true);
		})
		// Move pickers
		.on('mousemove.minicolors touchmove.minicolors', function(event) {
			var target = $(document).data('minicolors-target');
			if( target ) move(target, event);
		})
		// Stop moving
		.on('mouseup.minicolors touchend.minicolors', function() {
			$(this).removeData('minicolors-target');
		})
		// Show panel when swatch is clicked
		.on('mousedown.minicolors touchstart.minicolors', '.minicolors-swatch', function(event) {
			var input = $(this).parent().find('.minicolors-input');
			event.preventDefault();
			show(input);
		})
		// Show on focus
		.on('focus.minicolors', '.minicolors-input', function() {
			var input = $(this);
			if( !input.data('minicolors-initialized') ) return;
			show(input);
		})
		// Fix hex on blur
		.on('blur.minicolors', '.minicolors-input', function() {
			var input = $(this),
				settings = input.data('minicolors-settings');
			if( !input.data('minicolors-initialized') ) return;
			
			// Parse Hex
			input.val(parseHex(input.val(), true));
			
			// Is it blank?
			if( input.val() === '' ) input.val(parseHex(settings.defaultValue, true));
			
			// Adjust case
			input.val( convertCase(input.val(), settings.letterCase) );
			
		})
		// Handle keypresses
		.on('keydown.minicolors', '.minicolors-input', function(event) {
			var input = $(this);
			if( !input.data('minicolors-initialized') ) return;
			switch(event.keyCode) {
				case 9: // tab
					hide();
					break;
				case 13: // enter
				case 27: // esc
					hide();
					input.blur();
					break;
			}
		})
		// Update on keyup
		.on('keyup.minicolors', '.minicolors-input', function() {
			var input = $(this);
			if( !input.data('minicolors-initialized') ) return;
			updateFromInput(input, true);
		})
		// Update on paste
		.on('paste.minicolors', '.minicolors-input', function() {
			var input = $(this);
			if( !input.data('minicolors-initialized') ) return;
			setTimeout( function() {
				updateFromInput(input, true);
			}, 1);
		});
	
})(jQuery);;/*global jQuery, document*/

(function($) {
    "use strict";
    $(document).ready(function() {
        $('.ace-editor').each(function(index, element) {
            var area = element;
            var editor = $(element).attr('data-editor');

            var aceeditor = ace.edit(editor);
            aceeditor.setTheme("ace/theme/" + jQuery(element).attr('data-theme'));
            aceeditor.getSession().setMode("ace/mode/" + $(element).attr('data-mode'));

            aceeditor.on('change', function(e) {
                $('#' + area.id).val(aceeditor.getSession().getValue());
                redux_change($(element));
            });
        });
    });
})(jQuery);;/* global redux_change, wp */

(function($) {
    "use strict";

    $.reduxBackground = $.reduxBackground || {};

    $(document).ready(function() {
        $.reduxBackground.init();
    });

    /**
     * Redux Background
     * Dependencies		: jquery, wp media uploader
     * Feature added by	: Dovy Paukstys
     * Date				: 07 Jan 2014
     */
    $.reduxBackground.init = function() {
        // Remove the image button
        $('.redux-container-background .remove-image, .redux-container-background .remove-file').unbind('click').on('click', function(e) {
            $.reduxBackground.removeImage($(this).parents('fieldset.redux-field:first'));
            $.reduxBackground.preview($(this));
            return false;
        });

        // Upload media button
        $('.redux-container-background .background_upload_button').unbind().on('click', function(event) {
            $.reduxBackground.addImage(event, $(this).parents('fieldset.redux-field:first'));
        });

        $('.redux-background-input').on('change', function() {
            $.reduxBackground.preview($(this));
        });

        $('.redux-container-background .redux-color').wpColorPicker({
            change: function(u, ui) {
                redux_change($(this));
                $('#' + u.target.id + '-transparency').removeAttr('checked');
                $(this).val(ui.color.toString());
                $.reduxBackground.preview($(this));
            }
        });


    };

    // Update the background preview
    $.reduxBackground.preview = function(selector) {
        var parent = selector.parents('.redux-container-background:first');
        var preview = $(parent).find('.background-preview');

        if (!preview) { // No preview present
            return;
        }

        var split = parent.data('id') + '][';
        var css = 'height:' + preview.height() + 'px;';
        $(parent).find('.redux-background-input').each(function() {
            var data = $(this).serializeArray();
            data = data[0];

            if (data && data.name.indexOf('[background-') != -1) {
                if (data.value !== "") {
                    data.name = data.name.split(split);
                    data.name = data.name[1].replace(']', '');
                    if (data.name == "background-image") {
                        css += data.name + ':url("' + data.value + '");';
                    } else {
                        css += data.name + ':' + data.value + ';';
                    }
                }
            }
        });

        preview.attr('style', css).fadeIn();

    };

    // Add a file via the wp.media function
    $.reduxBackground.addImage = function(event, selector) {

        event.preventDefault();

        var frame;
        var jQueryel = $(this);

        // If the media frame already exists, reopen it.
        if (frame) {
            frame.open();
            return;
        }

        // Create the media frame.
        frame = wp.media({
            multiple: false,
            library: {
                //type: 'image' //Only allow images
            },
            // Set the title of the modal.
            title: jQueryel.data('choose'),
            // Customize the submit button.
            button: {
                // Set the text of the button.
                text: jQueryel.data('update')
                        // Tell the button not to close the modal, since we're
                        // going to refresh the page when the image is selected.

            }
        });

        // When an image is selected, run a callback.
        frame.on('select', function() {
            // Grab the selected attachment.
            var attachment = frame.state().get('selection').first();
            frame.close();

            //console.log(attachment.attributes.type);

            if (attachment.attributes.type !== "image") {
                return;
            }

            selector.find('.upload').val(attachment.attributes.url);
            selector.find('.upload-id').val(attachment.attributes.id);
            selector.find('.upload-height').val(attachment.attributes.height);
            selector.find('.upload-width').val(attachment.attributes.width);
            redux_change($(selector).find('.upload-id'));
            var thumbSrc = attachment.attributes.url;
            if (typeof attachment.attributes.sizes !== 'undefined' && typeof attachment.attributes.sizes.thumbnail !== 'undefined') {
                thumbSrc = attachment.attributes.sizes.thumbnail.url;
            } else if (typeof attachment.attributes.sizes !== 'undefined') {
                var height = attachment.attributes.height;
                for (var key in attachment.attributes.sizes) {
                    var object = attachment.attributes.sizes[key];
                    if (object.height < height) {
                        height = object.height;
                        thumbSrc = object.url;
                    }
                }
            } else {
                thumbSrc = attachment.attributes.icon;
            }
            selector.find('.upload-thumbnail').val(thumbSrc);
            if (!selector.find('.upload').hasClass('noPreview')) {
                selector.find('.screenshot').empty().hide().append('<img class="redux-option-image" src="' + thumbSrc + '">').slideDown('fast');
            }
            //selector.find('.media_upload_button').unbind();
            selector.find('.remove-image').removeClass('hide');//show "Remove" button
            selector.find('.redux-background-input-properties').slideDown();
            $.reduxBackground.preview(selector.find('.upload'));
        });

        // Finally, open the modal.
        frame.open();
    };

    // Update the background preview
    $.reduxBackground.removeImage = function(selector) {

        // This shouldn't have been run...
        if (!selector.find('.remove-image').addClass('hide')) {
            return;
        }
        selector.find('.remove-image').addClass('hide');//hide "Remove" button
        selector.find('.upload').val('');
        selector.find('.upload-id').val('');
        selector.find('.upload-height').val('');
        selector.find('.upload-width').val('');
        redux_change($(selector).find('.upload-id'));
        selector.find('.redux-background-input-properties').hide();
        var screenshot = selector.find('.screenshot');

        // Hide the screenshot
        screenshot.slideUp();

        selector.find('.remove-file').unbind();
        // We don't display the upload button if .upload-notice is present
        // This means the user doesn't have the WordPress 3.5 Media Library Support
        if ($('.section-upload .upload-notice').length > 0) {
            $('.background_upload_button').remove();
        }

        //$.reduxBackground.preview(selector);
    };
})(jQuery);
;/*
 Field Border (border)
 */

(function($) {
    "use strict";
    $(document).ready(function() {

        $(".redux-border-top, .redux-border-right, .redux-border-bottom, .redux-border-left, .redux-border-all").numeric({
            allowMinus: false,
        });

        $(".redux-border-style").select2({
            triggerChange: true,
            allowClear: true
        });

        $('.redux-border-input').on('change', function() {
            var units = $(this).parents('.redux-field:first').find('.field-units').val();
            if ($(this).parents('.redux-field:first').find('.redux-border-units').length !== 0) {
                units = $(this).parents('.redux-field:first').find('.redux-border-units option:selected').val();
            }
            var value = $(this).val();
            if (typeof units !== 'undefined' && value) {
                value += units;
            }
            if ($(this).hasClass('redux-border-all')) {
                $(this).parents('.redux-field:first').find('.redux-border-value').each(function() {
                    $(this).val(value);
                });
            } else {
                $('#' + $(this).attr('rel')).val(value);
            }
        });
        $('.redux-border-units').on('change', function() {
            $(this).parents('.redux-field:first').find('.redux-border-input').change();
        });

    });
})(jQuery);;
/*
 Field Button Set (button_set)
 */

/*global jQuery, document*/

(function($) {
    "use strict";
    
    $(document).ready(function() {
        $('.buttonset').each(function() {
            if ($(this).is(':checkbox')) {
                $(this).find('.buttonset-item').button();
            }
            
            $(this).buttonset();
        });
    });
})(jQuery);;
/*
 Field Color (color)
 */

/*global jQuery, document, redux_change */

(function($) {
    'use strict';

    $.redux = $.redux || {};

    $(document).ready(function() {
        $.redux.color();
    });

    $.redux.color = function() {
        $('.redux-color-init').wpColorPicker({
            change: function(u) {
                redux_change($(this));
                $('#' + u.target.id + '-transparency').removeAttr('checked');
            },
            clear: function() {
                redux_change($(this).parent().find('.redux-color-init'));
            }
        });

        $('.redux-color').on('focus', function() {
            $(this).data('oldcolor', $(this).val());
        });

        $('.redux-color').on('keyup', function() {
            var value = $(this).val();
            var color = redux_color_validate(this);
            var id = '#' + $(this).attr('id');
            if (value === "transparent") {
                $(this).parent().parent().find('.wp-color-result').css('background-color', 'transparent');
                $(id + '-transparency').attr('checked', 'checked');
            } else {
                $(id + '-transparency').removeAttr('checked');
                if (color && color !== $(this).val()) {
                    $(this).val(color);
                }
            }
        });

        // Replace and validate field on blur
        $('.redux-color').on('blur', function() {
            var value = $(this).val();
            var id = '#' + $(this).attr('id');
            if (value === "transparent") {
                $(this).parent().parent().find('.wp-color-result').css('background-color', 'transparent');
                $(id + '-transparency').attr('checked', 'checked');
            } else {
                if (redux_color_validate(this) === value) {
                    if (value.indexOf("#") !== 0) {
                        $(this).val($(this).data('oldcolor'));
                    }
                }
                $(id + '-transparency').removeAttr('checked');
            }
        });

        // Store the old valid color on keydown
        $('.redux-color').on('keydown', function() {
            $(this).data('oldkeypress', $(this).val());
        });

        // When transparency checkbox is clicked
        $('.color-transparency').on('click', function() {
            if ($(this).is(":checked")) {
                $('#' + $(this).data('id')).val('transparent');
                $('#' + $(this).data('id')).parent().parent().find('.wp-color-result').css('background-color', 'transparent');
            } else {
                if ($('#' + $(this).data('id')).val() === 'transparent') {
                    $('#' + $(this).data('id')).val('');
                }
            }
        });
    };

})(jQuery);


// Name check, converts name to hex
function colourNameToHex(colour) {
    var tcolour = colour.replace(/^\s\s*/, '').replace(/\s\s*$/, '').replace("#", "");
    var colours = {
        "aliceblue": "#f0f8ff",
        "antiquewhite": "#faebd7",
        "aqua": "#00ffff",
        "aquamarine": "#7fffd4",
        "azure": "#f0ffff",
        "beige": "#f5f5dc",
        "bisque": "#ffe4c4",
        "black": "#000000",
        "blanchedalmond": "#ffebcd",
        "blue": "#0000ff",
        "blueviolet": "#8a2be2",
        "brown": "#a52a2a",
        "burlywood": "#deb887",
        "cadetblue": "#5f9ea0",
        "chartreuse": "#7fff00",
        "chocolate": "#d2691e",
        "coral": "#ff7f50",
        "cornflowerblue": "#6495ed",
        "cornsilk": "#fff8dc",
        "crimson": "#dc143c",
        "cyan": "#00ffff",
        "darkblue": "#00008b",
        "darkcyan": "#008b8b",
        "darkgoldenrod": "#b8860b",
        "darkgray": "#a9a9a9",
        "darkgreen": "#006400",
        "darkkhaki": "#bdb76b",
        "darkmagenta": "#8b008b",
        "darkolivegreen": "#556b2f",
        "darkorange": "#ff8c00",
        "darkorchid": "#9932cc",
        "darkred": "#8b0000",
        "darksalmon": "#e9967a",
        "darkseagreen": "#8fbc8f",
        "darkslateblue": "#483d8b",
        "darkslategray": "#2f4f4f",
        "darkturquoise": "#00ced1",
        "darkviolet": "#9400d3",
        "deeppink": "#ff1493",
        "deepskyblue": "#00bfff",
        "dimgray": "#696969",
        "dodgerblue": "#1e90ff",
        "firebrick": "#b22222",
        "floralwhite": "#fffaf0",
        "forestgreen": "#228b22",
        "fuchsia": "#ff00ff",
        "gainsboro": "#dcdcdc",
        "ghostwhite": "#f8f8ff",
        "gold": "#ffd700",
        "goldenrod": "#daa520",
        "gray": "#808080",
        "green": "#008000",
        "greenyellow": "#adff2f",
        "honeydew": "#f0fff0",
        "hotpink": "#ff69b4",
        "indianred ": "#cd5c5c",
        "indigo ": "#4b0082",
        "ivory": "#fffff0",
        "khaki": "#f0e68c",
        "lavender": "#e6e6fa",
        "lavenderblush": "#fff0f5",
        "lawngreen": "#7cfc00",
        "lemonchiffon": "#fffacd",
        "lightblue": "#add8e6",
        "lightcoral": "#f08080",
        "lightcyan": "#e0ffff",
        "lightgoldenrodyellow": "#fafad2",
        "lightgrey": "#d3d3d3",
        "lightgreen": "#90ee90",
        "lightpink": "#ffb6c1",
        "lightsalmon": "#ffa07a",
        "lightseagreen": "#20b2aa",
        "lightskyblue": "#87cefa",
        "lightslategray": "#778899",
        "lightsteelblue": "#b0c4de",
        "lightyellow": "#ffffe0",
        "lime": "#00ff00",
        "limegreen": "#32cd32",
        "linen": "#faf0e6",
        "magenta": "#ff00ff",
        "maroon": "#800000",
        "mediumaquamarine": "#66cdaa",
        "mediumblue": "#0000cd",
        "mediumorchid": "#ba55d3",
        "mediumpurple": "#9370d8",
        "mediumseagreen": "#3cb371",
        "mediumslateblue": "#7b68ee",
        "mediumspringgreen": "#00fa9a",
        "mediumturquoise": "#48d1cc",
        "mediumvioletred": "#c71585",
        "midnightblue": "#191970",
        "mintcream": "#f5fffa",
        "mistyrose": "#ffe4e1",
        "moccasin": "#ffe4b5",
        "navajowhite": "#ffdead",
        "navy": "#000080",
        "oldlace": "#fdf5e6",
        "olive": "#808000",
        "olivedrab": "#6b8e23",
        "orange": "#ffa500",
        "orangered": "#ff4500",
        "orchid": "#da70d6",
        "palegoldenrod": "#eee8aa",
        "palegreen": "#98fb98",
        "paleturquoise": "#afeeee",
        "palevioletred": "#d87093",
        "papayawhip": "#ffefd5",
        "peachpuff": "#ffdab9",
        "peru": "#cd853f",
        "pink": "#ffc0cb",
        "plum": "#dda0dd",
        "powderblue": "#b0e0e6",
        "purple": "#800080",
        "red": "#ff0000",
        "redux": "#01a3e3",
        "rosybrown": "#bc8f8f",
        "royalblue": "#4169e1",
        "saddlebrown": "#8b4513",
        "salmon": "#fa8072",
        "sandybrown": "#f4a460",
        "seagreen": "#2e8b57",
        "seashell": "#fff5ee",
        "sienna": "#a0522d",
        "silver": "#c0c0c0",
        "skyblue": "#87ceeb",
        "slateblue": "#6a5acd",
        "slategray": "#708090",
        "snow": "#fffafa",
        "springgreen": "#00ff7f",
        "steelblue": "#4682b4",
        "tan": "#d2b48c",
        "teal": "#008080",
        "thistle": "#d8bfd8",
        "tomato": "#ff6347",
        "turquoise": "#40e0d0",
        "violet": "#ee82ee",
        "wheat": "#f5deb3",
        "white": "#ffffff",
        "whitesmoke": "#f5f5f5",
        "yellow": "#ffff00",
        "yellowgreen": "#9acd32"
    };
    if (colours[tcolour.toLowerCase()] !== 'undefined') {
        return colours[tcolour.toLowerCase()];
    }
    return colour;
}



// Run the validation
function redux_color_validate(field) {
    var value = jQuery(field).val();
    if (colourNameToHex(value) !== value.replace('#', '')) {
        return colourNameToHex(value);
    }
    return value;
}
;/*global jQuery, document, redux_change */

(function($) {
    'use strict';

    $.redux = $.redux || {};

    $(document).ready(function() {
        $.redux.color_rgba();
    });

    $.redux.color_rgba = function() {
        $('.redux-color_rgba-init').minicolors({
            animationSpeed:     50,
            animationEasing:    'swing',
            inline:             false,
            letterCase:         'lowercase',
            position:           'bottom left',
            theme:              'default',
            opacity:            true,
            //theme: 'bootstrap',
            change: function(hex, opacity) {
                redux_change($(this));

                $('#' + $(this).data('id') + '-transparency').removeAttr('checked');
                $('#' + $(this).data('id') + '-alpha').val(opacity);
            }
        });

        $('.redux-color_rgba').on('focus', function() {
            $(this).data('oldcolor', $(this).val());
        });

        $('.redux-color_rgba').on('keyup', function() {
            var value = $(this).val();
            var color = redux_color_rgba_validate(this);
            var id = '#' + $(this).attr('id');

            if (value === "transparent") {
                $('#' + $(this).data('id')).parent().parent().find('.minicolors-swatch-color').attr('style', '');
                $(id + '-transparency').attr('checked', 'checked');
            } else {
                $(id + '-transparency').removeAttr('checked');
                if (color && color !== $(this).val()) {
                    $(this).val(color);
                }
            }
        });

        // Replace and validate field on blur
        $('.redux-color_rgba').on('blur', function() {
            var value = $(this).val();
            var id = '#' + $(this).attr('id');

            if (value === "transparent") {
                $('#' + $(this).data('id')).parent().parent().find('.minicolors-swatch-color').attr('style', '');
                $(id + '-transparency').attr('checked', 'checked');
            } else {
                if (redux_color_validate(this) === value) {
                    if (value.indexOf("#") !== 0) {
                        $(this).val($(this).data('oldcolor'));
                    }
                }
                $(id + '-transparency').removeAttr('checked');
            }
        });

        // Store the old valid color on keydown
        $('.redux-color_rgba').on('keydown', function() {
            $(this).data('oldkeypress', $(this).val());
        });

        $('.color_rgba-transparency').on('click', function() {
            // Getting the specific input based from field ID
            var pfs = $(this).parent().parent().data('id');
            var op = $(this).parent().parent().find('.minicolors-swatch-color').css('opacity').substring(0, 4);

            if ($(this).is(":checked")) {

                //Set data-opacity attribute to 0.00 when transparent checkbox is check
                $('#' + $(this).data('id')).attr('data-opacity', '0.00');

                //Set hidded input value alpha opacity to 0.00 when transparent checkbox is check
                $('#' + pfs + '-alpha').val('0.00');

                //Hide .minicolors-swatch-color SPAN when its check
                $('#' + $(this).data('id')).parent().parent().find('.minicolors-swatch-color').css('display', 'none');
            } else {

                //might need to restore data-opacity attribute and hidden input alpha value when uncheck
                $('#' + $(this).data('id')).attr('data-opacity', op);
                $('#' + pfs + '-alpha').val(op);

                //Unhide .minicolors-swatch-color SPAN when its check
                $('#' + $(this).data('id')).parent().parent().find('.minicolors-swatch-color').css('display', '');
            }
        });

        //Unhide .minicolors-swatch-color SPAN when its check on redux-color_rgba input focus
        $('.redux-color_rgba').on('focus', function() {

            var op = $(this).parent().find('.minicolors-swatch-color').css('opacity').substring(0, 4);

            // re-store data-opacity value of the input field
            $(this).attr('data-opacity', op);

            // re-store alpha hidden input value (not really nescessary)
            $('#' + $(this).parent().parent().data('id') + '-alpha').val(op);

            //unhide .mini-swatch-color
            $(this).parent().find('.minicolors-swatch-color').css('display', '');
        });
    };
})(jQuery);

// Run the validation
function redux_color_rgba_validate(field) {
    var value = jQuery(field).val();
    /*
     if (colourNameToHex(value) !== value.replace('#', '')) {
     return colourNameToHex(value);
     }
     */
    return value;
};/*global jQuery*/

(function($) {
    "use strict";

    $(document).ready(function() {
        $('.redux-datepicker').each(function() {
            $(this).datepicker();
        });
    });
})(jQuery);;(function($) {
    "use strict";

    $(document).ready(function() {

        $(".redux-dimensions-height, .redux-dimensions-width").numeric({
            //allowMinus   : false,
        });

        $(".redux-dimensions-units").select2({
            width: 'resolve',
            triggerChange: true,
            allowClear: true
        });

        $('.redux-dimensions-input').on('change', function() {
            var units = $(this).parents('.redux-field:first').find('.field-units').val();
            if ($(this).parents('.redux-field:first').find('.redux-dimensions-units').length !== 0) {
                units = $(this).parents('.redux-field:first').find('.redux-dimensions-units option:selected').val();
            }
            if (typeof units !== 'undefined') {
                $('#' + $(this).attr('rel')).val($(this).val() + units);
            } else {
                $('#' + $(this).attr('rel')).val($(this).val());
            }
        });

        $('.redux-dimensions-units').on('change', function() {
            $(this).parents('.redux-field:first').find('.redux-dimensions-input').change();
        });
    });
})(jQuery);;/* global redux_change, wp */

(function($) {
    "use strict";

    $.gallery = $.gallery || {};

    $(document).ready(function() {
        //gallery insert functionality
        $.gallery();
    });

    $.gallery = function() {

        // When the user clicks on the Add/Edit gallery button, we need to display the gallery editing
        $('body').on({
            click: function(event) {
                var current_gallery = $(this).closest('fieldset');

                if (event.currentTarget.id === 'clear-gallery') {
                    //remove value from input

                    var rmVal = current_gallery.find('.gallery_values').val('');

                    //remove preview images
                    current_gallery.find(".screenshot").html("");

                    return;

                }

                // Make sure the media gallery API exists
                if (typeof wp === 'undefined' || !wp.media || !wp.media.gallery) {
                    return;
                }
                event.preventDefault();

                // Activate the media editor
                var $$ = $(this);

                var val = current_gallery.find('.gallery_values').val();
                var final;

                if (!val) {
                    final = '[gallery ids="0"]';
                } else {
                    final = '[gallery ids="' + val + '"]';
                }

                var frame = wp.media.gallery.edit(final);

                // When the gallery-edit state is updated, copy the attachment ids across
                frame.state('gallery-edit').on('update', function(selection) {

                    //clear screenshot div so we can append new selected images
                    current_gallery.find(".screenshot").html("");

                    var element, preview_html = "", preview_img;
                    var ids = selection.models.map(function(e) {
                        element         = e.toJSON();
                        preview_img     = typeof element.sizes.thumbnail !== 'undefined' ? element.sizes.thumbnail.url : element.url;
                        preview_html    = "<a class='of-uploaded-image' href='" + preview_img + "'><img class='redux-option-image' src='" + preview_img + "' alt='' /></a>";
                        current_gallery.find(".screenshot").append(preview_html);

                        return e.id;
                    });

                    current_gallery.find('.gallery_values').val(ids.join(','));
                    redux_change(current_gallery.find('.gallery_values'));

                });

                return false;
            }
        }, '.gallery-attachments');
    };
})(jQuery);;/* global redux_change */
(function($){
    "use strict";

    $.redux.group = $.group || {};
	
    $(document).ready(function () {
        //Group functionality
        $.redux.group();
    });
    
    $.redux.group = function(){
        $("#redux-groups-accordion")
        .accordion({
            header: "> div > h3",
            collapsible: true,
            active: false,
            heightStyle: "content",
            icons: {
                "header": "ui-icon-plus",
                "activeHeader": "ui-icon-minus"
            }
        })
        .sortable({
            axis: "y",
            handle: "h3",
            stop: function (event, ui) {
                // IE doesn't register the blur when sorting
                // so trigger focusout handlers to remove .ui-state-focus
                ui.item.children("h3").triggerHandler("focusout");
                var inputs = $('input.slide-sort');
                inputs.each(function(idx) {
                    $(this).val(idx);
                });
            }
        });
        
        $('.redux-groups-accordion-group input[data-title="true"]').on('keyup',function(event) {
            $(this).closest('.redux-groups-accordion-group').find('.redux-groups-header').text(event.target.value);
            $(this).closest('.redux-groups-accordion-group').find('.slide-title').val(event.target.value);
        });

        $('.redux-groups-remove').live('click', function () {
            redux_change($(this));
            $(this).parent().find('input[type="text"]').val('');
            $(this).parent().find('input[type="hidden"]').val('');
            $(this).parent().parent().slideUp('medium', function () {
                $(this).remove();
            });
        });

        $('.redux-groups-add').click(function () {

            var newSlide = $(this).prev().find('.redux-dummy').clone(true).show();
            var slideCounter = $(this).parent().find('.redux-dummy-slide-count');
            // Count # of slides
            var slideCount = slideCounter.val();
            // Update the slideCounter
            slideCounter.val(parseInt(slideCount)+1 );
            // REMOVE var slideCount1 = slideCount*1 + 1;

            //$(newSlide).find('h3').text('').append('<span class="redux-groups-header">New Group</span><span class="ui-accordion-header-icon ui-icon ui-icon-plus"></span>');
            $(this).prev().append(newSlide);

            // Remove dummy classes from newSlide
            $(newSlide).removeClass("redux-dummy");

            $(newSlide).find('input[type="text"], input[type="hidden"], textarea , select').each(function(){
                var attr_name = $(this).data('name');
                var attr_id = $(this).attr('id');
                // For some browsers, `attr` is undefined; for others,
                // `attr` is false.  Check for both.
                if (typeof attr_id !== 'undefined' && attr_id !== false) {
                    $(this).attr("id", $(this).attr("id").replace("@", slideCount) );
                }
                if (typeof attr_name !== 'undefined' && attr_name !== false) {
                    $(this).attr("name", $(this).data("name").replace("@", slideCount) );
                }

                if($(this).prop("tagName") == 'SELECT') {
                    //we clean select2 first
                    $(newSlide).find('.select2-container').remove();
                    $(newSlide).find('select').removeClass('select2-offscreen');
                }

                $(this).val('');
                if ($(this).hasClass('slide-sort')){
                    $(this).val(slideCount);
                }
            });
        });
    };
})(jQuery);
;/* global confirm, redux, redux_change */

(function($) {
    "use strict";

    $(document).ready(function() {

        // On label click, change the input and class
        $('.redux-image-select label img, .redux-image-select label .tiles').click(function(e) {
            var id = $(this).closest('label').attr('for');

            $(this).parents("fieldset:first").find('.redux-image-select-selected').removeClass('redux-image-select-selected').find("input[type='radio']").attr("checked", false);
            $(this).closest('label').find('input[type="radio"]').prop('checked');

            if ($(this).closest('label').hasClass('redux-image-select-preset-' + id)) { // If they clicked on a preset, import!
                e.preventDefault();

                var presets = $(this).closest('label').find('input');
                var data = presets.data('presets');

                if (presets !== undefined && presets !== null) {
                    var answer = confirm(redux.args.preset_confirm);

                    if (answer) {
                        $('label[for="' + id + '"]').addClass('redux-image-select-selected').find("input[type='radio']").attr("checked", true);
                        window.onbeforeunload = null;
                        $('#import-code-value').val(JSON.stringify(data));
                        $('#redux-import').click();
                    }
                } else {
                }

                return false;
            } else {
                $('label[for="' + id + '"]').addClass('redux-image-select-selected').find("input[type='radio']").attr("checked", true);

                redux_change($(this).closest('label').find('input[type="radio"]'));
            }
        });

        // Used to display a full image preview of a tile/pattern
        $('.tiles').qtip({
            content: {
                text: function(event, api) {
                    return "<img src='" + $(this).attr('rel') + "' style='max-width:150px;' alt='' />";
                },
            },
            style: 'qtip-tipsy',
            position: {
                my: 'top center', // Position my top left...
                at: 'bottom center', // at the bottom right of...
            }
        });
    });
})(jQuery);;(function($) {
    "use strict";
    
    $(document).ready(function() {
        $('#redux-import').click(function(e) {
            if ($('#import-code-value').val() === "" && $('#import-link-value').val() === "") {
                e.preventDefault();
                return false;
            }
            window.onbeforeunload = null;
        });      
        
        $('#redux-import-code-button').click(function() {
            if ($('#redux-import-link-wrapper').is(':visible')) {
                $('#redux-import-link-wrapper').hide();
                $('#import-link-value').val('');
            }
            $('#redux-import-code-wrapper').fadeIn('fast');
        });
        
        $('#redux-import-link-button').click(function() {
            if ($('#redux-import-code-wrapper').is(':visible')) {
                $('#redux-import-code-wrapper').hide();
                $('#import-code-value').val('');
            }
            $('#redux-import-link-wrapper').fadeIn('fast');
        });
        
        $('#redux-export-code-copy').click(function() {
            if ($('#redux-export-link-value').is(':visible')) {
                $('#redux-export-link-value').hide();
            }
            $('#redux-export-code').fadeIn('fast');
        });
        
        $('#redux-export-link').click(function() {
            if ($('#redux-export-code').is(':visible')) {
                $('#redux-export-code').hide();
            }
            $('#redux-export-link-value').fadeIn('fast');
        }); 
        
    });
})(jQuery);
;/* global redux_change, wp */


// Add a file via the wp.media function
function redux_add_file(event, selector) {
    event.preventDefault();

    var frame;
    var jQueryel = jQuery(this);

    // If the media frame already exists, reopen it.
    if (frame) {
        frame.open();
        return;
    }

    // Create the media frame.
    frame = wp.media({
        multiple: false,
        library: {
            //type: 'image' //Only allow images
        },

        // Set the title of the modal.
        title: jQueryel.data('choose'),

        // Customize the submit button.
        button: {
            // Set the text of the button.
            text: jQueryel.data('update')
            // Tell the button not to close the modal, since we're
            // going to refresh the page when the image is selected.
        }
    });

    // When an image is selected, run a callback.
    frame.on('select', function() {

        // Grab the selected attachment.
        var attachment = frame.state().get('selection').first();
        frame.close();
        if (typeof redux.media === 'undefined') {
            redux.media = {};
        }
        if (typeof redux.media[jQuery(selector).attr('data-id')] === 'undefined') {
            redux.media[jQuery(selector).attr('data-id')] = {};
            redux.media[jQuery(selector).attr('data-id')].mode = "image";
        }

        if (redux.media[jQuery(selector).attr('data-id')].mode !== false && attachment.attributes.type !== redux.media[jQuery(selector).attr('data-id')].mode) {
            return;
        }

        selector.find('.upload').val(attachment.attributes.url);
        selector.find('.upload-id').val(attachment.attributes.id);
        selector.find('.upload-height').val(attachment.attributes.height);
        selector.find('.upload-width').val(attachment.attributes.width);
        redux_change(jQuery(selector).find('.upload-id'));
        var thumbSrc = attachment.attributes.url;
        if (typeof attachment.attributes.sizes !== 'undefined' && typeof attachment.attributes.sizes.thumbnail !== 'undefined') {
            thumbSrc = attachment.attributes.sizes.thumbnail.url;
        } else if (typeof attachment.attributes.sizes !== 'undefined') {
            var height = attachment.attributes.height;
            for (var key in attachment.attributes.sizes) {
                var object = attachment.attributes.sizes[key];
                if (object.height < height) {
                    height = object.height;
                    thumbSrc = object.url;
                }
            }
        } else {
            thumbSrc = attachment.attributes.icon;
        }
        selector.find('.upload-thumbnail').val(thumbSrc);
        if (!selector.find('.upload').hasClass('noPreview')) {
            selector.find('.screenshot').empty().hide().append('<img class="redux-option-image" src="' + thumbSrc + '">').slideDown('fast');
        }
        //selector.find('.media_upload_button').unbind();
        selector.find('.remove-image').removeClass('hide');//show "Remove" button
        selector.find('.redux-background-properties').slideDown();
    });

    // Finally, open the modal.
    frame.open();
}


// Function to remove the image on click. Still requires a save
function redux_remove_file(selector) {

    // This shouldn't have been run...
    if (!selector.find('.remove-image').addClass('hide')) {
        return;
    }
    selector.find('.remove-image').addClass('hide');//hide "Remove" button
    selector.find('.upload').val('');
    selector.find('.upload-id').val('');
    selector.find('.upload-height').val('');
    selector.find('.upload-width').val('');
    selector.find('.upload-thumbnail').val('');
    redux_change(jQuery(selector).find('.upload-id'));
    selector.find('.redux-background-properties').hide();
    var screenshot = selector.find('.screenshot');

    // Hide the screenshot
    screenshot.slideUp();

    selector.find('.remove-file').unbind();
    // We don't display the upload button if .upload-notice is present
    // This means the user doesn't have the WordPress 3.5 Media Library Support
    if (jQuery('.section-upload .upload-notice').length > 0) {
        jQuery('.media_upload_button').remove();
    }

}

(function($) {
    "use strict";

    $.redux = $.redux || {};

    $(document).ready(function() {
        $.redux.media();
    });

    /**
     * Media Uploader
     * Dependencies		: jquery, wp media uploader
     * Feature added by	: Smartik - http://smartik.ws/
     * Date				: 05.28.2013
     */
    $.redux.media = function() {
        // Remove the image button
        $('.remove-image, .remove-file').unbind('click').on('click', function() {
            redux_remove_file($(this).parents('fieldset.redux-field:first'));
        });

        // Upload media button
        $('.media_upload_button').unbind().on('click', function(event) {
            redux_add_file(event, $(this).parents('fieldset.redux-field:first'));
        });
    };

})(jQuery);
;/* global redux_change */

(function($) {
    "use strict";

    $.redux = $.redux || {};

    $(document).ready(function() {
        //multi text functionality
        $.redux.multi_text();
    });

    $.redux.multi_text = function() {
        $('.redux-multi-text-remove').live('click', function() {
            redux_change($(this));
            $(this).prev('input[type="text"]').val('');
            $(this).parent().slideUp('medium', function() {
                $(this).remove();
            });
        });

        $('.redux-multi-text-add').click(function() {
            var number = parseInt($(this).attr('data-add_number'));
            var id = $(this).attr('data-id');
            var name = $(this).attr('data-name');
            for (var i = 0; i < number; i++) {
                var new_input = $('#' + id + ' li:last-child').clone();
                $('#' + id).append(new_input);
                $('#' + id + ' li:last-child').removeAttr('style');
                $('#' + id + ' li:last-child input[type="text"]').val('');
                $('#' + id + ' li:last-child input[type="text"]').attr('name', name);
            }
        });
    };
})(jQuery);;/* global redux_change */

(function($) {
    "use strict";

    $.redux = $.redux || {};

    $(document).ready(function() {
        $.redux.select();
    });

    $.redux.select = function() {
        $('select.redux-select-item').each(function() {

            var default_params = {
                width:          'resolve',
                triggerChange:  true,
                allowClear:     true
            };

            if ($(this).siblings('.select2_params').size() > 0) {
                var select2_params = $(this).siblings('.select2_params').val();
                select2_params = JSON.parse(select2_params);
                default_params = $.extend({}, default_params, select2_params);
            }

            if ($(this).hasClass('font-icons')) {
                default_params = $.extend({}, {formatResult: addIconToSelect, formatSelection: addIconToSelect, escapeMarkup: function(m) {
                        return m;
                    }}, default_params);
            }

            $(this).select2(default_params);

            if ($(this).hasClass('select2-sortable')) {
                default_params = {};
                default_params.bindOrder = 'sortableStop';
                default_params.sortableOptions = {placeholder: 'ui-state-highlight'};
                $(this).select2Sortable(default_params);
            }

            $(this).on("change", function() {
                redux_change($($(this)));
                $(this).select2SortableOrder();
            });
        });
    };

    function addIconToSelect(icon) {
        if (icon.hasOwnProperty('id')) {
            return "<span class='elusive'><i class='" + icon.id + "'></i>" + "&nbsp;&nbsp;" + icon.id.toUpperCase() + "</span>";
        }
    }
})(jQuery);;(function($) {
    "use strict";

    $('.redux-select-image-item').on('change', function() {
        var preview = $(this).parents('.redux-field:first').find('.redux-preview-image');

        if ($(this).val() === "") {
            preview.fadeOut('medium', function() {
                preview.attr('src', '');
            });
        } else {
            preview.attr('src', $(this).val());
            preview.fadeIn().css('visibility', 'visible');
        }
    });
})(jQuery);;(function($) {
    "use strict";

    // Return true for float value, false otherwise
    function is_float(mixed_var) {
        return +mixed_var === mixed_var && (!(isFinite(mixed_var))) || Boolean((mixed_var % 1));
    }

    // Return number of integers after the decimal point.
    function decimalCount(res) {
        var q = res.toString().split('.');
        return q[1].length;
    }

    function loadSelect(myClass, min, max, res, step) {

        //var j = step + ((decCount ) - (step )); //  18;

        for (var i = min; i <= max; i = i + res) {
            //var step = 2;

            //if (j === (step + ((decCount ) - (step )))) {
            var n = i;
            if (is_float(res)) {
                var decCount = decimalCount(res);
                n = i.toFixed(decCount);
            }

            $(myClass).append(
                    '<option value="' + n + '">' + n + '</option>'
                    );
            //j = 0;
            //}
            //j++;
        }
    }

    $(document).ready(function() {
        $('div.redux-slider-container').each(function() {

            var start, toClass, defClassOne, defClassTwo, connectVal;
            var DISPLAY_NONE    = 0;
            var DISPLAY_LABEL   = 1;
            var DISPLAY_TEXT    = 2;
            var DISPLAY_SELECT  = 3;

            var mainID = $(this).data('id');

            var minVal          = $(this).data('min');
            var maxVal          = $(this).data('max');
            var stepVal         = $(this).data('step');
            var handles         = $(this).data('handles');
            var defValOne       = $(this).data('default-one');
            var defValTwo       = $(this).data('default-two');
            var resVal          = $(this).data('resolution');
            var displayValue    = parseInt(($(this).data('display')));
            var rtlVal          = Boolean($(this).data('rtl'));
            var floatMark       = ($(this).data('float-mark'));

            var rtl;
            if (rtlVal === true) {
                rtl = 'rtl';
            } else {
                rtl = 'ltr';
            }

            // range array
            var range = [minVal, maxVal];

            // Set default values for dual slides.
            var startTwo = [defValOne, defValTwo];

            // Set default value for single slide
            var startOne = [defValOne];

            var inputOne, inputTwo;
            if (displayValue == DISPLAY_TEXT) {
                defClassOne = $('.redux-slider-input-one-' + mainID);
                defClassTwo = $('.redux-slider-input-two-' + mainID);

                inputOne = defClassOne;
                inputTwo = defClassTwo;
            } else if (displayValue == DISPLAY_SELECT) {
                defClassOne = $('.redux-slider-select-one-' + mainID);
                defClassTwo = $('.redux-slider-select-two-' + mainID);

                loadSelect(defClassOne, minVal, maxVal, resVal, stepVal);

                if (handles === 2) {
                    loadSelect(defClassTwo, minVal, maxVal, resVal, stepVal);
                }

            } else if (displayValue == DISPLAY_LABEL) {
                defClassOne = $('#redux-slider-label-one-' + mainID);
                defClassTwo = $('#redux-slider-label-two-' + mainID);
            } else if (displayValue == DISPLAY_NONE) {
                defClassOne = $('.redux-slider-value-one-' + mainID);
                defClassTwo = $('.redux-slider-value-two-' + mainID);
            }

            var classOne, classTwo;
            if (displayValue == DISPLAY_LABEL) {
                var x = [defClassOne, 'html'];
                var y = [defClassTwo, 'html'];

                classOne = [x];
                classTwo = [x, y];
            } else {
                classOne = [defClassOne];
                classTwo = [defClassOne, defClassTwo];
            }

            if (handles === 2) {
                start       = startTwo;
                toClass     = classTwo;
                connectVal  = true;
            } else {
                start = startOne;
                toClass     = classOne;
                connectVal  = 'lower';
            }

            var slider = $(this).noUiSlider({
                range:      range,
                start:      start,
                handles:    handles,
                step:       stepVal,
                connect:    connectVal,
                behaviour:  "tap-drag",
                direction:  rtl,
                serialization: {
                    resolution: resVal,
                    to:         toClass,
                    mark:       floatMark,
                },
                slide: function() {
                    if (displayValue == DISPLAY_LABEL) {
                        if (handles === 2) {
                            var inpSliderVal = slider.val();
                            $('input.redux-slider-value-one-' + mainID).attr('value', inpSliderVal[0]);
                            $('input.redux-slider-value-two-' + mainID).attr('value', inpSliderVal[1]);
                        } else {
                            $('input.redux-slider-value-one-' + mainID).attr('value', slider.val());
                        }
                    }

                    if (displayValue == DISPLAY_SELECT) {
                        $('.redux-slider-select-one').select2('val', slider.val()[0]);

                        if (handles === 2) {
                            $('.redux-slider-select-two').select2('val', slider.val()[1]);
                        }
                    }

                    redux_change(jQuery(this).parents('.redux-field-container:first').find('input'));
                },
            });

            if (displayValue === DISPLAY_TEXT) {
                inputOne.keydown(function(e) {

                    var sliderOne = slider.val();
                    var value = parseInt(sliderOne[0]);

                    switch (e.which) {
                        case 38:
                            slider.val([value + 1, null]);
                            break;
                        case 40:
                            slider.val([value - 1, null]);
                            break;
                        case 13:
                            e.preventDefault();
                            break;
                    }
                });

                if (handles === 2) {
                    inputTwo.keydown(function(e) {
                        var sliderTwo = slider.val();
                        var value = parseInt(sliderTwo[1]);

                        switch (e.which) {
                            case 38:
                                slider.val([null, value + 1]);
                                break;
                            case 40:
                                slider.val([null, value - 1]);
                                break;
                            case 13:
                                e.preventDefault();
                                break;
                        }
                    });
                }
            }
        });
        $('select.redux-slider-select-one, select.redux-slider-select-two').select2({
            width:          'resolve',
            triggerChange:  true,
            allowClear:     true
        });
    });
})(jQuery);
;/* global redux_change, wp */

(function($) {
    "use strict";

    $(document).ready(function() {

        $('.redux-slides-remove').live('click', function() {
            redux_change(jQuery(this));
            $(this).parent().siblings().find('input[type="text"]').val('');
            $(this).parent().siblings().find('textarea').val('');
            $(this).parent().siblings().find('input[type="hidden"]').val('');

            var slideCount = $(this).parents('.redux-container-slides:first').find('.redux-slides-accordion-group').length;

            if (slideCount > 1) {
                $(this).parents('.redux-slides-accordion-group:first').slideUp('medium', function() {
                    $(this).remove();
                });
            } else {
                $(this).parents('.redux-slides-accordion-group:first').find('.remove-image').click();
                $(this).parents('.redux-container-slides:first').find('.redux-slides-accordion-group:last').find('.redux-slides-header').text("New Slide");
            }
        });

        $('.redux-slides-add').click(function() {

            var newSlide = $(this).prev().find('.redux-slides-accordion-group:last').clone(true);
            var slideCount = $(newSlide).find('.slide-title').attr("name").match(/[0-9]+(?!.*[0-9])/);
            var slideCount1 = slideCount * 1 + 1;

            $(newSlide).find('input[type="text"], input[type="hidden"], textarea').each(function() {

                $(this).attr("name", jQuery(this).attr("name").replace(/[0-9]+(?!.*[0-9])/, slideCount1)).attr("id", $(this).attr("id").replace(/[0-9]+(?!.*[0-9])/, slideCount1));
                $(this).val('');
                if ($(this).hasClass('slide-sort')) {
                    $(this).val(slideCount1);
                }
            });

            $(newSlide).find('.screenshot').removeAttr('style');
            $(newSlide).find('.screenshot').addClass('hide');
            $(newSlide).find('.screenshot a').attr('href', '');
            $(newSlide).find('.remove-image').addClass('hide');
            $(newSlide).find('.redux-slides-image').attr('src', '').removeAttr('id');
            $(newSlide).find('h3').text('').append('<span class="redux-slides-header">New slide</span><span class="ui-accordion-header-icon ui-icon ui-icon-plus"></span>');
            $(this).prev().append(newSlide);
        });

        $('.slide-title').keyup(function(event) {
            var newTitle = event.target.value;
            $(this).parents().eq(3).find('.redux-slides-header').text(newTitle);
        });

        $(function() {
            $(".redux-slides-accordion")
                .accordion({
                    header: "> div > fieldset > h3",
                    collapsible: true,
                    active: false,
                    heightStyle: "content",
                    icons: {"header": "ui-icon-plus", "activeHeader": "ui-icon-minus"}
                })
                .sortable({
                    axis: "y",
                    handle: "h3",
                    connectWith: ".redux-slides-accordion",
                    start: function(e, ui) {
                        ui.placeholder.height(ui.item.height());
                        ui.placeholder.width(ui.item.width());
                    },
                    placeholder: "ui-state-highlight",
                    stop: function(event, ui) {
                        // IE doesn't register the blur when sorting
                        // so trigger focusout handlers to remove .ui-state-focus
                        ui.item.children("h3").triggerHandler("focusout");
                        var inputs = $('input.slide-sort');
                        inputs.each(function(idx) {
                            $(this).val(idx);
                        });
                    }
                });
        });
    });
})(jQuery);;/*global jQuery, document, redux_change */

(function($) {
    "use strict";
    
    $(document).ready(function() {
        $(".redux-sortable").sortable({
            handle: ".drag",
            placeholder: "ui-state-highlight",
            opacity: 0.7,
            update: function() {
                redux_change($(this));
            }
        });

        $('.checkbox_sortable').on('click', function() {
            if ($(this).is(":checked")) {
                $('#' + $(this).attr('rel')).val(1);
            } else {
                $('#' + $(this).attr('rel')).val('');
            }
        });
    });
})(jQuery);;
(function($) {
    "use strict";
    $(function() {
        /**        Sorter (Layout Manager) */
        $('.redux-sorter').each(function() {
            var id = $(this).attr('id');

            $('#' + id).find('ul').sortable({
                items:          'li',
                placeholder:    "placeholder",
                connectWith:    '.sortlist_' + id,
                opacity:        0.6,
                update:         function() {
                    $(this).find('.position').each(function() {
                        var listID      = $(this).parent().attr('id');
                        var parentID    = $(this).parent().parent().attr('id');

                        parentID = parentID.replace(id + '_', '');
                        redux_change($(this));

                        var optionID = $(this).parent().parent().parent().attr('id');

                        $(this).prop("name", redux.args.opt_name + '[' + optionID + '][' + parentID + '][' + listID + ']');
                    });
                }
            });
        });
    });
})(jQuery);;/* global redux, redux_opts */
/*
 * Field Sorter jquery function
 * Based on
 * [SMOF - Slightly Modded Options Framework](http://aquagraphite.com/2011/09/slightly-modded-options-framework/)
 * Version 1.4.2
 */

(function($) {
    "use strict";
    
    $(function() {
        /**	Sorter (Layout Manager) */
        $('.redux-sorter').each(function() {
            var id = $(this).attr('id');
            
            $('#' + id).find('ul').sortable({
                items:          'li',
                placeholder:    "placeholder",
                connectWith:    '.sortlist_' + id,
                opacity:        0.8,
                stop: function(event, ui) {
                    var sorter = redux.sorter[$(this).attr('data-id')];
                    var id = $(this).find('h3').text();

                    if (sorter.limits && id && sorter.limits[id]) {
                        if ($(this).children('li').length >= sorter.limits[id]) {
                            $(this).addClass('filled');
                            if ($(this).children('li').length > sorter.limits[id]) {
                                $(ui.sender).sortable('cancel');
                            }
                        } else {
                            $(this).removeClass('filled');
                        }
                    }
                },
                update: function(event, ui) {
                    var sorter  = redux.sorter[$(this).attr('data-id')];
                    var id      = $(this).find('h3').text();
                    
                    if (sorter.limits && id && sorter.limits[id]) {
                        if ($(this).children('li').length >= sorter.limits[id]) {
                            $(this).addClass('filled');
                            if ($(this).children('li').length > sorter.limits[id]) {
                                $(ui.sender).sortable('cancel');
                            }
                        } else {
                            $(this).removeClass('filled');
                        }
                    }

                    $(this).find('.position').each(function() {
                        var listID      = $(this).parent().attr('id');
                        var parentID    = $(this).parent().parent().attr('data-group-id');
                        
                        redux_change($(this));
                        
                        var optionID = $(this).parent().parent().parent().attr('id');
                        
                        $(this).prop("name", redux.args.opt_name + '[' + optionID + '][' + parentID + '][' + listID + ']');
                    });
                }
            });
        });
    });
})(jQuery);;(function($) {
    "use strict";

    $(document).ready(function() {

        $(".redux-spacing-top, .redux-spacing-right, .redux-spacing-bottom, .redux-spacing-left, .redux-spacing-all").numeric({
            //allowMinus   : false,
        });

        $(".redux-spacing-units").select2({
            width:          '80px',
            triggerChange:  true,
            allowClear:     true
        });

        $('.redux-spacing-input').on('change', function() {
            var units = $(this).parents('.redux-field:first').find('.field-units').val();

            if ($(this).parents('.redux-field:first').find('.redux-spacing-units').length !== 0) {
                units = $(this).parents('.redux-field:first').find('.redux-spacing-units option:selected').val();
            }

            var value = $(this).val();

            if (typeof units !== 'undefined' && value) {
                value += units;
            }

            if ($(this).hasClass('redux-spacing-all')) {
                $(this).parents('.redux-field:first').find('.redux-spacing-value').each(function() {
                    $(this).val(value);
                });
            } else {
                $('#' + $(this).attr('rel')).val(value);
            }
        });
        $('.redux-spacing-units').on('change', function() {
            $(this).parents('.redux-field:first').find('.redux-spacing-input').change();
        });

    });
})(jQuery);;/* global redux_change */

(function($) {
    "use strict";

    $(document).ready(function() {

        $('.redux_spinner').each(function() {
            //slider init
            var spinner = redux.spinner[$(this).attr('rel')];

            $("#" + spinner.id).spinner({
                value:  parseInt(spinner.val, null),
                min:    parseInt(spinner.min, null),
                max:    parseInt(spinner.max, null),
                step:   parseInt(spinner.step, null),
                range:  "min",

                slide: function(event, ui) {
                    var input = $("#" + spinner.id);
                    input.val(ui.value);
                    redux_change(input);
                }
            });

            // Limit input for negative
            var neg = false;
            if (parseInt(spinner.min, null) < 0) {
                neg = true;
            }

            $("#" + spinner.id).numeric({
                allowMinus: neg,
                min:        spinner.min,
                max:        spinner.max
            });

        });

        // Update the slider from the input and vice versa
        $(".spinner-input").keyup(function() {
            $(this).addClass('spinnerInputChange');
        });

        function cleanSpinnerValue(value, selector, spinner) {

            if (!selector.hasClass('spinnerInputChange')) {
                return;
            }
            selector.removeClass('spinnerInputChange');

            if (value === "" || value === null) {
                value = spinner.min;
            } else if (value >= parseInt(spinner.max)) {
                value = spinner.max;
            } else if (value <= parseInt(spinner.min)) {
                value = spinner.min;
            } else {
                value = Math.round(value / spinner.step) * spinner.step;
            }

            $("#" + spinner.id).val(value);

        }

        // Update the spinner from the input and vice versa
        $(".spinner-input").blur(function() {
            //        cleanSpinnerValue(jQuery(this).val(), jQuery(this), redux.spinner[jQuery(this).attr('id')]);
        });

        $(".spinner-input").focus(function() {
            cleanSpinnerValue($(this).val(), $(this), redux.spinner[$(this).attr('id')]);
        });

        $('.spinner-input').typeWatch({
            callback: function(value) {
                cleanSpinnerValue(value, $(this), redux.spinner[$(this).attr('id')]);
            },

            wait:           500,
            highlight:      false,
            captureLength:  1
        });
    });
})(jQuery);;/* global redux_change */
(function($) {
    "use strict";

    $.redux = $.redux || {};

    $(document).ready(function() {
        $.redux.switch();
    });

    /**
     * Switch
     * Dependencies		: jquery
     * Feature added by	: Smartik - http://smartik.ws/
     * Date				: 03.17.2013
     */
    $.redux.switch = function() {
        $(".cb-enable").click(function() {
            if ($(this).hasClass('selected')) {
                return;
            }

            var parent = $(this).parents('.switch-options');

            $('.cb-disable', parent).removeClass('selected');
            $(this).addClass('selected');
            $('.checkbox-input', parent).val(1);

            redux_change($('.checkbox-input', parent));

            //fold/unfold related options
            var obj     = $(this);
            var $fold   = '.f_' + obj.data('id');

            $($fold).slideDown('normal', "swing");
        });
        $(".cb-disable").click(function() {

            if ($(this).hasClass('selected')) {
                return;
            }

            var parent = $(this).parents('.switch-options');

            $('.cb-enable', parent).removeClass('selected');
            $(this).addClass('selected');
            $('.checkbox-input', parent).val(0);

            redux_change($('.checkbox-input', parent));

            //fold/unfold related options
            var obj     = $(this);
            var $fold   = '.f_' + obj.data('id');

            $($fold).slideUp('normal', "swing");
        });

        $('.cb-enable span, .cb-disable span').find().attr('unselectable', 'on');
    };
})(jQuery);;// jQuery List DragSort v0.5.1
// License: http://dragsort.codeplex.com/license
(function(b){b.fn.dragsort=function(k){if("destroy"==k)b(this.selector).trigger("dragsort-uninit");else{var f=b.extend({},b.fn.dragsort.defaults,k),h=[],a=null,l=null;this.each(function(k,j){b(j).is("table")&&1==b(j).children().size()&&b(j).children().is("tbody")&&(j=b(j).children().get(0));var m={draggedItem:null,placeHolderItem:null,pos:null,offset:null,offsetLimit:null,scroll:null,container:j,init:function(){var a=0==b(this.container).children().size()?"li":b(this.container).children(":first").get(0).tagName.toLowerCase(); ""==f.itemSelector&&(f.itemSelector=a);""==f.dragSelector&&(f.dragSelector=a);""==f.placeHolderTemplate&&(f.placeHolderTemplate="<"+a+">&nbsp;</"+a+">");b(this.container).attr("data-listidx",k).mousedown(this.grabItem).bind("dragsort-uninit",this.uninit);this.styleDragHandlers(!0)},uninit:function(){var a=h[b(this).attr("data-listidx")];b(a.container).unbind("mousedown",a.grabItem).unbind("dragsort-uninit");a.styleDragHandlers(!1)},getItems:function(){return b(this.container).children(f.itemSelector)}, styleDragHandlers:function(a){this.getItems().map(function(){return b(this).is(f.dragSelector)?this:b(this).find(f.dragSelector).get()}).css("cursor",a?"pointer":"")},grabItem:function(a){if(!(1!=a.which||b(a.target).is(f.dragSelectorExclude)||0<b(a.target).closest(f.dragSelectorExclude).size()||0==b(a.target).closest(f.itemSelector).size())){a.preventDefault();for(var c=a.target;!b(c).is(f.dragSelector);){if(c==this)return;c=c.parentNode}b(c).attr("data-cursor",b(c).css("cursor"));b(c).css("cursor", "move");var e=h[b(this).attr("data-listidx")],g=this,i=function(){e.dragStart.call(g,a);b(e.container).unbind("mousemove",i)};b(e.container).mousemove(i).mouseup(function(){b(e.container).unbind("mousemove",i);b(c).css("cursor",b(c).attr("data-cursor"))})}},dragStart:function(d){null!=a&&null!=a.draggedItem&&a.dropItem();a=h[b(this).attr("data-listidx")];a.draggedItem=b(d.target).closest(f.itemSelector);a.draggedItem.attr("data-origpos",b(this).attr("data-listidx")+"-"+a.getItems().index(a.draggedItem)); var c=parseInt(a.draggedItem.css("marginTop")),e=parseInt(a.draggedItem.css("marginLeft"));a.offset=a.draggedItem.offset();a.offset.top=d.pageY-a.offset.top+(isNaN(c)?0:c)-1;a.offset.left=d.pageX-a.offset.left+(isNaN(e)?0:e)-1;f.dragBetween||(c=0==b(a.container).outerHeight()?Math.max(1,Math.round(0.5+a.getItems().size()*a.draggedItem.outerWidth()/b(a.container).outerWidth()))*a.draggedItem.outerHeight():b(a.container).outerHeight(),a.offsetLimit=b(a.container).offset(),a.offsetLimit.right=a.offsetLimit.left+ b(a.container).outerWidth()-a.draggedItem.outerWidth(),a.offsetLimit.bottom=a.offsetLimit.top+c-a.draggedItem.outerHeight());c=a.draggedItem.height();e=a.draggedItem.width();"tr"==f.itemSelector?(a.draggedItem.children().each(function(){b(this).width(b(this).width())}),a.placeHolderItem=a.draggedItem.clone().attr("data-placeholder",!0),a.draggedItem.after(a.placeHolderItem),a.placeHolderItem.children().each(function(){b(this).css({borderWidth:0,width:b(this).width()+1,height:b(this).height()+1}).html("&nbsp;")})): (a.draggedItem.after(f.placeHolderTemplate),a.placeHolderItem=a.draggedItem.next().css({height:c,width:e}).attr("data-placeholder",!0));if("td"==f.itemSelector){var g=a.draggedItem.closest("table").get(0);b("<table id='"+g.id+"' style='border-width: 0px;' class='dragSortItem "+g.className+"'><tr></tr></table>").appendTo("body").children().append(a.draggedItem)}g=a.draggedItem.attr("style");a.draggedItem.attr("data-origstyle",g?g:"");a.draggedItem.css({position:"absolute",opacity:0.8,"z-index":999, height:c,width:e});a.scroll={moveX:0,moveY:0,maxX:b(document).width()-b(window).width(),maxY:b(document).height()-b(window).height()};a.scroll.scrollY=window.setInterval(function(){if(f.scrollContainer!=window)b(f.scrollContainer).scrollTop(b(f.scrollContainer).scrollTop()+a.scroll.moveY);else{var c=b(f.scrollContainer).scrollTop();if(0<a.scroll.moveY&&c<a.scroll.maxY||0>a.scroll.moveY&&0<c)b(f.scrollContainer).scrollTop(c+a.scroll.moveY),a.draggedItem.css("top",a.draggedItem.offset().top+a.scroll.moveY+ 1)}},10);a.scroll.scrollX=window.setInterval(function(){if(f.scrollContainer!=window)b(f.scrollContainer).scrollLeft(b(f.scrollContainer).scrollLeft()+a.scroll.moveX);else{var c=b(f.scrollContainer).scrollLeft();if(0<a.scroll.moveX&&c<a.scroll.maxX||0>a.scroll.moveX&&0<c)b(f.scrollContainer).scrollLeft(c+a.scroll.moveX),a.draggedItem.css("left",a.draggedItem.offset().left+a.scroll.moveX+1)}},10);b(h).each(function(a,b){b.createDropTargets();b.buildPositionTable()});a.setPos(d.pageX,d.pageY);b(document).bind("mousemove", a.swapItems);b(document).bind("mouseup",a.dropItem);f.scrollContainer!=window&&b(window).bind("DOMMouseScroll mousewheel",a.wheel)},setPos:function(d,c){var e=c-this.offset.top,g=d-this.offset.left;f.dragBetween||(e=Math.min(this.offsetLimit.bottom,Math.max(e,this.offsetLimit.top)),g=Math.min(this.offsetLimit.right,Math.max(g,this.offsetLimit.left)));this.draggedItem.parents().each(function(){if("static"!=b(this).css("position")&&(!b.browser.mozilla||"table"!=b(this).css("display"))){var a=b(this).offset(); e-=a.top;g-=a.left;return!1}});if(f.scrollContainer==window)c-=b(window).scrollTop(),d-=b(window).scrollLeft(),c=Math.max(0,c-b(window).height()+5)+Math.min(0,c-5),d=Math.max(0,d-b(window).width()+5)+Math.min(0,d-5);else var i=b(f.scrollContainer),h=i.offset(),c=Math.max(0,c-i.height()-h.top)+Math.min(0,c-h.top),d=Math.max(0,d-i.width()-h.left)+Math.min(0,d-h.left);a.scroll.moveX=0==d?0:d*f.scrollSpeed/Math.abs(d);a.scroll.moveY=0==c?0:c*f.scrollSpeed/Math.abs(c);this.draggedItem.css({top:e,left:g})}, wheel:function(d){if((b.browser.safari||b.browser.mozilla)&&a&&f.scrollContainer!=window){var c=b(f.scrollContainer),e=c.offset();d.pageX>e.left&&d.pageX<e.left+c.width()&&d.pageY>e.top&&d.pageY<e.top+c.height()&&(e=d.detail?5*d.detail:d.wheelDelta/-2,c.scrollTop(c.scrollTop()+e),d.preventDefault())}},buildPositionTable:function(){var d=[];this.getItems().not([a.draggedItem[0],a.placeHolderItem[0]]).each(function(a){var e=b(this).offset();e.right=e.left+b(this).outerWidth();e.bottom=e.top+b(this).outerHeight(); e.elm=this;d[a]=e});this.pos=d},dropItem:function(){if(null!=a.draggedItem){var d=a.draggedItem.attr("data-origstyle");a.draggedItem.attr("style",d);""==d&&a.draggedItem.removeAttr("style");a.draggedItem.removeAttr("data-origstyle");a.styleDragHandlers(!0);a.placeHolderItem.before(a.draggedItem);a.placeHolderItem.remove();b("[data-droptarget], .dragSortItem").remove();window.clearInterval(a.scroll.scrollY);window.clearInterval(a.scroll.scrollX);a.draggedItem.attr("data-origpos")!=b(h).index(a)+"-"+ a.getItems().index(a.draggedItem)&&f.dragEnd.apply(a.draggedItem);a.draggedItem.removeAttr("data-origpos");a.draggedItem=null;b(document).unbind("mousemove",a.swapItems);b(document).unbind("mouseup",a.dropItem);f.scrollContainer!=window&&b(window).unbind("DOMMouseScroll mousewheel",a.wheel);return!1}},swapItems:function(d){if(null==a.draggedItem)return!1;a.setPos(d.pageX,d.pageY);for(var c=a.findPos(d.pageX,d.pageY),e=a,g=0;-1==c&&f.dragBetween&&g<h.length;g++)c=h[g].findPos(d.pageX,d.pageY),e=h[g]; if(-1==c)return!1;var i=function(){return b(e.container).children().not(e.draggedItem)},d=i().not(f.itemSelector).each(function(){this.idx=i().index(this)});null==l||l.top>a.draggedItem.offset().top||l.left>a.draggedItem.offset().left?b(e.pos[c].elm).before(a.placeHolderItem):b(e.pos[c].elm).after(a.placeHolderItem);d.each(function(){var a=i().eq(this.idx).get(0);this!=a&&i().index(this)<this.idx?b(this).insertAfter(a):this!=a&&b(this).insertBefore(a)});b(h).each(function(a,b){b.createDropTargets(); b.buildPositionTable()});l=a.draggedItem.offset();return!1},findPos:function(a,b){for(var e=0;e<this.pos.length;e++)if(this.pos[e].left<a&&this.pos[e].right>a&&this.pos[e].top<b&&this.pos[e].bottom>b)return e;return-1},createDropTargets:function(){f.dragBetween&&b(h).each(function(){var d=b(this.container).find("[data-placeholder]"),c=b(this.container).find("[data-droptarget]");0<d.size()&&0<c.size()?c.remove():0==d.size()&&0==c.size()&&("td"==f.itemSelector?b(f.placeHolderTemplate).attr("data-droptarget", !0).appendTo(this.container):b(this.container).append(a.placeHolderItem.removeAttr("data-placeholder").clone().attr("data-droptarget",!0)),a.placeHolderItem.attr("data-placeholder",!0))})}};m.init();h.push(m)});return this}};b.fn.dragsort.defaults={itemSelector:"",dragSelector:"",dragSelectorExclude:"input, textarea",dragEnd:function(){},dragBetween:!1,placeHolderTemplate:"",scrollContainer:window,scrollSpeed:5}})(jQuery);

/*global jQuery, document*/
jQuery(document).ready(function($) {
	jQuery("ul.text_sortable").dragsort({
		dragSelector: ".drag",
		dragBetween: true,
		dragEnd: triggerSaveNotice
	});

	function triggerSaveNotice() {
		jQuery('#redux-opts-save-warn').slideDown('slow');
	};
});
;/* global redux_change */
/**
 * Typography
 * Dependencies:        google.com, jquery
 * Feature added by:    Dovy Paukstys - http://simplerain.com/
 * Date:                06.14.2013
 */
jQuery.noConflict();
/** Fire up jQuery - let's dance!
 */
jQuery(document).ready(function($) {

    Object.size = function(obj) {
        var size = 0,
                key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                size++;
            }
        }
        return size;
    };

    function typographySelect(selector) {
        var mainID = jQuery(selector).parents('.redux-container-typography:first').attr('data-id');
        if ($(selector).hasClass('redux-typography-family')) {
            //$('#' + mainID + ' .typography-style span').text('');
            //$('#' + mainID + ' .typography-script span').text('');
        }
        // Set all the variables to be checked against
        var family = $('#' + mainID + ' select.redux-typography-family').val();
        if (!family) {
            family = null; //"inherit";
        }
        var familyBackup = $('#' + mainID + ' select.redux-typography-family-backup').val();
        var size = $('#' + mainID + ' .redux-typography-size').val();
        var height = $('#' + mainID + ' .redux-typography-height').val();
        var word = $('#' + mainID + ' .redux-typography-word').val(); // New Word-Spacing
        var letter = $('#' + mainID + ' .redux-typography-letter').val(); // New Letter-Spacing
        var align = $('#' + mainID + ' select.redux-typography-align').val(); // text-align
        var transform = $('#' + mainID + ' select.redux-typography-transform').val();
        var style = $('#' + mainID + ' select.redux-typography-style').val();
        var script = $('#' + mainID + ' select.redux-typography-subsets').val();
        var color = $('#' + mainID + ' .redux-typography-color').val();
        var units = $('#' + mainID).data('units');
        var option = $('#' + mainID + ' .redux-typography-family option:selected');
        var output = family;
        //$('#' + mainID + ' select.redux-typography-style').val('');
        //$('#' + mainID + ' select.redux-typography-subsets').val('');
        var google = option.data('google'); // Check if font is a google font
        // Page load. Speeds things up memory wise to offload to client
        if (!$('#' + mainID).hasClass('typography-initialized')) {
            style = $('#' + mainID + ' select.redux-typography-style').data('value');
            script = $('#' + mainID + ' select.redux-typography-subsets').data('value');
            if (style !== "") {
                style = String(style);
            }
            if (typeof (script) !== undefined) {
                script = String(script);
            }
            $('#' + mainID).addClass('typography-initialized');
        }
        // Get the styles and such from the font
        var details = "";

        // Something went wrong trying to read google fonts, so turn google off
        if (redux.fonts.google === undefined) {
            google = false;
        }

        if (google && ( family in redux.fonts.google)) {
            details = redux.fonts.google[family];
        } else if (option.data('details')) {
            details = jQuery.parseJSON(decodeURIComponent(option.data('details')));
            $('#' + mainID + ' .redux-typography-font-options').val(decodeURIComponent(option.data('details')));
        }

        // If we changed the font
        if ($(selector).hasClass('redux-typography-family')) {
            var html = '<option value=""></option>';
            if (google) { // Google specific stuff
                var selected = "";
                $.each(details.variants, function(index, variant) {
                    if (variant.id === style || Object.size(details.variants) === 1) {
                        selected = ' selected="selected"';
                        style = variant.id;
                    } else {
                        selected = "";
                    }
                    html += '<option value="' + variant.id + '"' + selected + '>' + variant.name.replace(/\+/g, " ") + '</option>';
                });
                $('#' + mainID + ' .redux-typography-style').html(html);
                selected = "";
                html = '<option value=""></option>';
                $.each(details.subsets, function(index, subset) {
                    if (subset.id === script || Object.size(details.subsets) === 1) {
                        selected = ' selected="selected"';
                        script = subset.id;
                    } else {
                        selected = "";
                    }
                    html += '<option value="' + subset.id + '"' + selected + '>' + subset.name.replace(/\+/g, " ") + '</option>';
                });
                if (typeof (familyBackup) !== "undefined" && familyBackup !== "") {
                    output += ', ' + familyBackup;
                }

                $('#' + mainID + ' .redux-typography-subsets').html(html);
                $('#' + mainID + ' .redux-typography-subsets').fadeIn('fast');
                $('#' + mainID + ' .typography-family-backup').fadeIn('fast');
            } else {
                if (details) {
                    $.each(details, function(index, value) {
                        if (index === style || index === "normal") {
                            selected = ' selected="selected"';
                            $('#' + mainID + ' .typography-style .select2-chosen').text(value);
                        } else {
                            selected = "";
                        }
                        html += '<option value="' + index + '"' + selected + '>' + value.replace('+', ' ') + '</option>';
                    });
                    $('#' + mainID + ' .redux-typography-style').html(html);
                    $('#' + mainID + ' .redux-typography-subsets').fadeOut('fast');
                    $('#' + mainID + ' .typography-family-backup').fadeOut('fast');
                }
            }
        } else if ($(selector).hasClass('redux-typography-family-backup') && familyBackup !== "") {
            $('#' + mainID + ' .redux-typography-font-family').val(output);
        }

        // Check if the selected value exists. If not, empty it. Else, apply it.
        if ($('#' + mainID + " select.redux-typography-style option[value='" + style + "']").length === 0) {
            style = "";
            $('#' + mainID + ' select.redux-typography-style').val('');
        } else if (style === "400") {
            $('#' + mainID + ' select.redux-typography-style').val(style);
        }
        if ($('#' + mainID + " select.redux-typography-subsets option[value='" + script + "']").length === 0) {
            script = "";
            $('#' + mainID + ' select.redux-typography-subsets').val('');
        }

        var _linkclass = 'style_link_' + mainID;

        //remove other elements crested in <head>
        $('.' + _linkclass).remove();
        if (family !== null && family !== "inherit") {
            //replace spaces with "+" sign
            var the_font = family.replace(/\s+/g, '+');
            if (google) {
                //add reference to google font family
                var link = the_font;
                if (style) {
                    link += ':' + style.replace(/\-/g, " ");
                }
                if (script) {
                    link += '&subset=' + script;
                }

                if (typeof (WebFont) !== "undefined" && WebFont) {
                    WebFont.load({google: {families: [link]}});
                }
                //link = 'http://fonts.googleapis.com/css?family=' + link;
                //$('head').append('<link href="' + link + '" rel="stylesheet" type="text/css" class="' + _linkclass + '">');
                $('#' + mainID + ' .redux-typography-google').val(true);
            } else {
                $('#' + mainID + ' .redux-typography-google').val(false);
            }
        }

        $('#' + mainID + ' .typography-preview').css('font-size', size + units);
        $('#' + mainID + ' .typography-preview').css('font-style', "normal");

        // Weight and italic
        if (style.indexOf("italic") !== -1) {
            $('#' + mainID + ' .typography-preview').css('font-style', 'italic');
            $('#' + mainID + ' .typography-font-style').val('italic');
            style = style.replace('italic', '');
        } else {
            $('#' + mainID + ' .typography-font-style').val('');
        }
        $('#' + mainID + ' .typography-font-weight').val(style);
        $('#' + mainID + ' .typography-preview').css('font-weight', style);

        //show in the preview box the font
        $('#' + mainID + ' .typography-preview').css('font-family', family + ', sans-serif');

        if (family === 'none' && family === '') {
            //if selected is not a font remove style "font-family" at preview box
            $('#' + mainID + ' .typography-preview').css('font-family', 'inherit');
        }
        if (!height) {
            height = size;
        }

        $('#' + mainID + ' .typography-preview').css('line-height', height + units);
        $('#' + mainID + ' .typography-preview').css('word-spacing', word + units);
        $('#' + mainID + ' .typography-preview').css('letter-spacing', letter + units);
        if (size === '') {
            $('#' + mainID + ' .typography-font-size').val('');
        } else {
            //console.log('here-font-size');
            $('#' + mainID + ' .typography-font-size').val(size + units);
        }
        if (height === '') {
            $('#' + mainID + ' .typography-line-height').val('');
        } else {
            $('#' + mainID + ' .typography-line-height').val(height + units);
        }
        $('#' + mainID + ' .typography-word-spacing').val(word + units);
        $('#' + mainID + ' .typography-letter-spacing').val(letter + units);

        if (color) {
            $('#' + mainID + ' .typography-preview').css('color', color);
            $('#' + mainID + ' .typography-preview').css('background-color', getContrastColour(color));
        }

        $('#' + mainID + ' .redux-typography-font-family').val(output);
        $('#' + mainID + ' .typography-style .select2-chosen').text($('#' + mainID + ' .redux-typography-style option:selected').text());
        $('#' + mainID + ' .typography-script .select2-chosen').text($('#' + mainID + ' .redux-typography-subsets option:selected').text());

        if (align) {
            $('#' + mainID + ' .typography-preview').css('text-align', align);
        }

        if (transform) {
            $('#' + mainID + ' .typography-preview').css('text-transform', transform);
        }

    }
    //init for each element
    jQuery('.redux-typography-container').each(function() {
        var family = jQuery(this).find('.redux-typography-family');
        if (family.data('value') !== "") {
            jQuery(family).val(family.data('value'));
        }
        typographySelect(family);
        window.onbeforeunload = null;
    });
    //init when value is changed
    jQuery('.redux-typography').on('change', function() {
        typographySelect(this);
    });
    //init when value is changed
    jQuery('.redux-typography-size, .redux-typography-height, .redux-typography-word, .redux-typography-letter, .redux-typography-align, .redux-typography-transform').keyup(function() {
        typographySelect(this);
    });
    // Have to redeclare the wpColorPicker to get a callback function
    $('.redux-typography-color').wpColorPicker({
        change: function(event, ui) {
            redux_change(jQuery(this));
            jQuery(this).val(ui.color.toString());
            typographySelect(jQuery(this));
        }
    });

    jQuery(".redux-typography-size").numeric({
        allowMinus: false,
    });

    jQuery(".redux-typography-height, .redux-typography-word, .redux-typography-letter").numeric({
        allowMinus: true,
    });
    //jQuery(".redux-typography-family, .redux-typography-style, .redux-typography-subsets").select2({
    jQuery(".redux-typography-family, .redux-typography-family-backup, .redux-typography-align, .redux-typography-transform").select2({
        width: 'resolve',
        triggerChange: true,
        allowClear: true
    });

    jQuery('.redux-typography-qtip').each(function() {
        $(this).qtip({
//            text: function(event, api) {
//                return $(this).attr('qtip-content');
//            },
            //text: 'Me',
            style: 'qtip-tipsy black',
            position: {
                my: 'bottom center', // Position my top left...
                at: 'top center', // at the bottom right of...
            }

        });
    });

});
;/* global jQuery, document, redux, redux.args, confirm, relid:true, console, jsonView */

(function($) {
    'use strict';

    $.redux = $.redux || {};

    $(document).ready(function() {
        // Intense debug  ;)
        //jQuery('input[type="hidden"]').attr("type","text");
        //console.log(redux);

        jQuery.fn.isOnScreen = function() {
            if (!window) {
                return;
            }

            var win = jQuery(window);
            var viewport = {
                top:    win.scrollTop(),
                left:   win.scrollLeft()
            };

            viewport.right  = viewport.left + win.width();
            viewport.bottom = viewport.top + win.height();

            var bounds = this.offset();

            bounds.right    = bounds.left + this.outerWidth();
            bounds.bottom   = bounds.top + this.outerHeight();

            return (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));
        };

        $.redux.required();

        $("body").on('change', '.redux-main select, .redux-main radio, .redux-main input[type=checkbox], .redux-main input[type=hidden]', function(e) {
            $.redux.check_dependencies(this);
        });

        $("body").on('check_dependencies', function(e, variable) {
            $.redux.check_dependencies(variable);
        });

        $('td > fieldset:empty,td > div:empty').parent().parent().hide();
    });

    $.redux.required = function() {

        // Hide the fold elements on load ,
        // It's better to do this by PHP but there is no filter in tr tag , so is not possible
        // we going to move each attributes we may need for folding to tr tag
        $.each(redux.folds, function(i, v) {
            var fieldset = $('#' + redux.args.opt_name + '-' + i);

            fieldset.parents('tr:first').addClass('fold');

            if (v == "hide") {
                fieldset.parents('tr:first').addClass('hide');

                if (fieldset.hasClass('redux-container-section')) {
                    var div = $('#section-' + i);
                    if (div.hasClass('redux-section-indent-start')) {
                        $('#section-table-' + i).hide().addClass('hide');
                        div.hide().addClass('hide');
                    }
                }

                if (fieldset.hasClass('redux-container-info')) {
                    $('#info-' + i).hide().addClass('hide');
                }

                if (fieldset.hasClass('redux-container-divide')) {
                    $('#divide-' + i).hide().addClass('hide');
                }
            }
        });
    };

    $.redux.get_container_value = function(id) {
        var value = $('#' + redux.args.opt_name + '-' + id).serializeForm();

        if (value !== null && typeof value === 'object' && value.hasOwnProperty(redux.args.opt_name)) {
            //console.log('object');
            //console.log(value);
            value = value[redux.args.opt_name][id];
        }
        //console.log(value);
        return value;
    };

    $.redux.check_dependencies = function(variable) {
        if (redux.required === null) {
            return;
        }
        var current = $(variable),
            id = current.parents('.redux-field:first').data('id');

        if (!redux.required.hasOwnProperty(id)) {
            return;
        }

        var container   = current.parents('.redux-field-container:first'),
            is_hidden   = container.parents('tr:first').hasClass('.hide'),
            hadSections = false;

        $.each(redux.required[id], function(child, dependents) {

            var current         = $(this),
                show            = false,
                childFieldset   = $('#' + redux.args.opt_name + '-' + child),
                tr              = childFieldset.parents('tr:first');

            if (!is_hidden) {
                show = $.redux.check_parents_dependencies(child);
            }

            if (show === true) {
                // Shim for sections
                if (childFieldset.hasClass('redux-container-section')) {
                    var div = $('#section-' + child);

                    if (div.hasClass('redux-section-indent-start') && div.hasClass('hide')) {
                        $('#section-table-' + child).fadeIn(300).removeClass('hide');
                        div.fadeIn(300).removeClass('hide');
                    }
                }

                if (childFieldset.hasClass('redux-container-info')) {
                    $('#info-' + child).fadeIn(300).removeClass('hide');
                }

                if (childFieldset.hasClass('redux-container-divide')) {
                    $('#divide-' + child).fadeIn(300).removeClass('hide');
                }

                tr.fadeIn(300, function() {
                    jQuery(this).removeClass('hide');
                    if (redux.required.hasOwnProperty(child)) {
                        $.redux.check_dependencies($('#' + redux.args.opt_name + '-' + child).children().first());
                    }
                });
            } else if (show === false) {
                tr.fadeOut(100, function() {
                    jQuery(this).addClass('hide');
                    if (redux.required.hasOwnProperty(child)) {
                        //console.log('Now check, reverse: '+child);
                        $.redux.required_recursive_hide(child);
                    }
                });
            }

            current.find('select, radio, input[type=checkbox]').trigger('change');
        });
    };

    $.redux.required_recursive_hide = function(id) {
        var toFade = $('#' + redux.args.opt_name + '-' + id).parents('tr:first');

        toFade.fadeOut(50, function() {
            jQuery(this).addClass('hide');

            if ($('#' + redux.args.opt_name + '-' + id).hasClass('redux-container-section')) {
                var div = $('#section-' + id);
                if (div.hasClass('redux-section-indent-start')) {
                    $('#section-table-' + id).fadeOut(50).addClass('hide');
                    div.fadeOut(50).addClass('hide');
                }
            }

            if ($('#' + redux.args.opt_name + '-' + id).hasClass('redux-container-info')) {
                $('#info-' + id).fadeOut(50).addClass('hide');
            }

            if ($('#' + redux.args.opt_name + '-' + id).hasClass('redux-container-divide')) {
                $('#divide-' + id).fadeOut(50).addClass('hide');
            }

            if (redux.required.hasOwnProperty(id)) {
                $.each(redux.required[id], function(child) {
                    $.redux.required_recursive_hide(child);
                });
            }
        });
    };

    $.redux.check_parents_dependencies = function(id) {
        var show = "";

        if (redux.required_child.hasOwnProperty(id)) {
            $.each(redux.required_child[id], function(i, parentData) {
                if ($('#' + redux.args.opt_name + '-' + parentData.parent).parents('tr:first').hasClass('.hide')) {
                    show = false;
                } else {
                    if (show !== false) {
                        var parentValue = $.redux.get_container_value(parentData.parent);
                        show = $.redux.check_dependencies_visibility(parentValue, parentData);
                    }
                }
            });
        } else {
            show = true;
        }
        return show;
    };

    $.redux.check_dependencies_visibility = function(parentValue, data) {
        var show        = false,
            checkValue_array,
            checkValue  = data.checkValue,
            operation   = data.operation;

        switch (operation) {
            case '=':
            case 'equals':
                //if value was array
                if ($.isArray(checkValue)) {
                    if ($.inArray(parentValue, checkValue) != -1) {
                        show = true;
                    }
                } else {
                    if (parentValue == checkValue) {
                        show = true;
                    } else if ($.isArray(parentValue)) {
                        if ($.inArray(checkValue, parentValue) != -1) {
                            show = true;
                        }
                    }
                }
                break;
            case '!=':
            case 'not':
                //if value was array
                if ($.isArray(checkValue)) {
                    //if (checkValue.toString().indexOf('|') !== -1) {
                    //    checkValue_array = checkValue.split('|');
                    if ($.inArray(parentValue, checkValue) == -1) {
                        show = true;
                    }
                } else {
                    if (parentValue != checkValue) {
                        show = true;
                    } else if ($.isArray(parentValue)) {
                        if ($.inArray(checkValue, parentValue) == -1) {
                            show = true;
                        }
                    }
                }
                break;
            case '>':
            case 'greater':
            case 'is_larger':
                if (parseFloat(parentValue) > parseFloat(checkValue))
                    show = true;
                break;
            case '>=':
            case 'greater_equal':
            case 'is_larger_equal':
                if (parseFloat(parentValue) >= parseFloat(checkValue))
                    show = true;
                break;
            case '<':
            case 'less':
            case 'is_smaller':
                if (parseFloat(parentValue) < parseFloat(checkValue))
                    show = true;
                break;
            case '<=':
            case 'less_equal':
            case 'is_smaller_equal':
                if (parseFloat(parentValue) <= parseFloat(checkValue))
                    show = true;
                break;
            case 'contains':
                if (parentValue.toString().indexOf(checkValue) != -1)
                    show = true;
                break;
            case 'doesnt_contain':
            case 'not_contain':
                if (parentValue.toString().indexOf(checkValue) == -1)
                    show = true;
                break;
            case 'is_empty_or':
                if (parentValue === "" || parentValue == checkValue)
                    show = true;
                break;
            case 'not_empty_and':
                if (parentValue !== "" && parentValue != checkValue)
                    show = true;
                break;
            case 'is_empty':
            case 'empty':
            case '!isset':
                if (!parentValue || parentValue === "" || parentValue === null)
                    show = true;
                break;
            case 'not_empty':
            case '!empty':
            case 'isset':
                if (parentValue && parentValue !== "" && parentValue !== null)
                    show = true;
                break;
        }
        return show;

    };

})(jQuery);

jQuery.noConflict();

var confirmOnPageExit = function(e) {
    //return; // ONLY FOR DEBUGGING
    // If we haven't been passed the event get the window.event
    e = e || window.event;

    var message = redux.args.save_pending;

    // For IE6-8 and Firefox prior to version 4
    if (e) {
        e.returnValue = message;
    }

    window.onbeforeunload = null;

    // For Chrome, Safari, IE8+ and Opera 12+
    return message;
};

function verifyPos(s, b) {

    // trim off spaces
    s = s.replace(/^\s+|\s+$/gm, '');

    // position value is blank, set the default
    if (s === '' || s.search(' ') == -1) {
        if (b === true) {
            return 'top left';
        } else {
            return 'bottom right';
        }
    }

    // split string into array
    var split = s.split(' ');

    // Evaluate first string.  Must be top, center, or bottom
    var paramOne = b ? 'top' : 'bottom';
    if (split[0] == 'top' || split[0] == 'center' || split[0] == 'bottom') {
        paramOne = split[0];
    }

    // Evaluate second string.  Must be left, center, or right.
    var paramTwo = b ? 'left' : 'right';
    if (split[1] == 'left' || split[1] == 'center' || split[1] == 'right') {
        paramTwo = split[1];
    }

    return paramOne + ' ' + paramTwo;
}

function getContrastColour(hexcolour) {
    // default value is black.
    retVal = '#444444';

    // In case - for some reason - a blank value is passed.
    // This should *not* happen.  If a function passing a value
    // is canceled, it should pass the current value instead of
    // a blank.  This is how the Windows Common Controls do it.  :P
    if (hexcolour !== '') {

        // Replace the hash with a blank.
        hexcolour = hexcolour.replace('#', '');

        var r = parseInt(hexcolour.substr(0, 2), 16);
        var g = parseInt(hexcolour.substr(2, 2), 16);
        var b = parseInt(hexcolour.substr(4, 2), 16);
        var res = ((r * 299) + (g * 587) + (b * 114)) / 1000;

        // Instead of pure black, I opted to use WP 3.8 black, so it looks uniform.  :) - kp
        retVal = (res >= 128) ? '#444444' : '#ffffff';
    }

    return retVal;
}

function verify_fold(item) {

    jQuery(document).ready(function($) {
        //console.log(verify_fold);

        if (item.hasClass('redux-info') || item.hasClass('redux-typography')) {
            return;
        }

        var id      = item.parents('.redux-field:first').data('id');
        var itemVal = item.val();

        if (redux.folds[ id ]) {

            /*
             if ( redux.folds[ id ].parent && jQuery( '#' + redux.folds[ id ].parent ).is('hidden') ) {
             console.log('Going to parent: '+redux.folds[ id ].parent+' for field: '+id);
             //verify_fold( jQuery( '#' + redux.folds[ id ].parent ) );
             }
             */
            if (redux.folds[ id ].children) {
                //console.log('Children for: '+id);

                var theChildren = {};
                $.each(redux.folds[ id ].children, function(index, value) {
                    $.each(value, function(index2, value2) { // Each of the children for this value
                        if (!theChildren[value2]) { // Create an object if it's not there
                            theChildren[value2] = {show: false, hidden: false};
                        }

                        //console.log('id: '+id+' childID: '+value2+' parent value: '+index+' itemVal: '+itemVal);

                        if (index == itemVal || theChildren[value2] === true) { // Check to see if it's in the criteria
                            theChildren[value2].show = true;
                            //console.log('theChildren['+value2+'].show = true');
                        }

                        if (theChildren[value2].show === true && jQuery('#' + id).parents("tr:first").hasClass("hiddenFold")) {
                            theChildren[value2].show = false; // If this item is hidden, hide this child
                            //console.log('set '+value2+' false');
                        }

                        if (theChildren[value2].show === true && jQuery('#' + redux.folds[ id ].parent).hasClass('hiddenFold')) {
                            theChildren[value2].show = false; // If the parent of the item is hidden, hide this child
                            //console.log('set '+value2+' false2');
                        }

                        // Current visibility of this child node
                        theChildren[value2].hidden = jQuery('#' + value2).parents("tr:first").hasClass("hiddenFold");
                    });
                });

                //console.log(theChildren);

                $.each(theChildren, function(index) {
                    var parent = jQuery('#' + index).parents("tr:first");

                    if (theChildren[index].show === true) {
                        //console.log('FadeIn '+index);

                        parent.fadeIn('medium', function() {
                            parent.removeClass('hiddenFold');
                            if (redux.folds[ index ] && redux.folds[ index ].children) {
                                //verify_fold(jQuery('#'+index)); // Now iterate the children
                            }
                        });

                    } else if (theChildren[index].hidden === false) {
                        //console.log('FadeOut '+index);

                        parent.fadeOut('medium', function() {
                            parent.addClass('hiddenFold');
                            if (redux.folds[ index ].children) {
                                //verify_fold(jQuery('#'+index)); // Now iterate the children
                            }
                        });
                    }
                });
            }
        }
    });
}

function redux_change(variable) {
    //We need this for switch and image select fields , jquery dosn't catch it on fly
    //if(variable.is('input[type=hidden]') || variable.hasClass('spinner-input') || variable.hasClass('slider-input') || variable.hasClass('upload') || jQuery(variable).parents('fieldset:eq(0)').is('.redux-container-image_select') ) {

    jQuery('body').trigger('check_dependencies', variable);
    //}

    if (variable.hasClass('compiler')) {
        jQuery('#redux-compiler-hook').val(1);
        //console.log('Compiler init');
    }


    if (variable.hasClass('foldParent')) {
        //verify_fold(variable);
    }

    window.onbeforeunload = confirmOnPageExit;

    if (jQuery(variable).parents('fieldset.redux-field:first').hasClass('redux-field-error')) {
        jQuery(variable).parents('fieldset.redux-field:first').removeClass('redux-field-error');
        jQuery(variable).parent().find('.redux-th-error').slideUp();

        var parentID    = jQuery(variable).closest('.redux-group-tab').attr('id');
        var rContainer = jQuery(variable).parents('.redux-container:first');

        var errorCount = ( parseInt( rContainer.find( '.redux-field-errors span').text() ) - 1 );
        var warningCount = ( parseInt( rContainer.find( '.redux-field-warnings span').text() ) - 1 );

        if (errorCount <= 0) {
            jQuery('#' + parentID + '_li .redux-menu-error').fadeOut('fast');
            jQuery('#' + parentID + '_li .redux-group-tab-link-a').removeClass('hasError');
            jQuery('#' + parentID + '_li').parents('.inside:first').find('.redux-field-errors').slideUp();
            jQuery(variable).parents('.redux-container:first').find('.redux-field-errors').slideUp();
        } else {
            // Let's count down the errors now. Fancy.  ;)
            var id = parentID.split('_');
            id = id[0];

            var th = rContainer.find('.redux-group-tab-link-li:eq('+id+')');

            var errorsLeft = ( parseInt( th.find('.redux-menu-error:first').text() ) - 1 );
            if ( errorsLeft <= 0 ) {
                th.find('.redux-menu-error:first').fadeOut().remove();
            } else {
                th.find('.redux-menu-error:first').text( errorsLeft );
            }

            var warningsLeft = ( parseInt( th.find('.redux-menu-warning:first').text() ) - 1 );
            if ( warningsLeft <= 0 ) {
                th.find('.redux-menu-warning:first').fadeOut().remove();
            } else {
                th.find('.redux-menu-warning:first').text( warningsLeft );
            }

            rContainer.find( '.redux-field-errors span').text( errorCount );
            rContainer.find( '.redux-field-warning span').text( warningCount );

        }
    }
    jQuery('.redux-save-warn').slideDown();
}

jQuery(document).ready(function($) {
    jQuery('.redux-action_bar, .redux-presets-bar').on('click', function() {
        window.onbeforeunload = null;
    });

    if (jQuery().qtip) {
        // Shadow
        var shadow      = '';
        var tip_shadow  = redux.args.hints.tip_style.shadow;

        if (tip_shadow === true) {
            shadow = 'qtip-shadow';
        }

        // Color
        var color       = '';
        var tip_color   = redux.args.hints.tip_style.color;

        if (tip_color !== '') {
            color = 'qtip-' + tip_color;
        }

        // Rounded
        var rounded     = '';
        var tip_rounded = redux.args.hints.tip_style.rounded;

        if (tip_rounded === true) {
            rounded = 'qtip-rounded';
        }

        // Tip style
        var style       = '';
        var tip_style   = redux.args.hints.tip_style.style;

        if (tip_style !== '') {
            style = 'qtip-' + tip_style;
        }

        var classes = shadow + ',' + color + ',' + rounded + ',' + style;
        classes     = classes.replace(/,/g, ' ');

        // Get position data
        var myPos = redux.args.hints.tip_position.my;
        var atPos = redux.args.hints.tip_position.at;

        // Gotta be lowercase, and in proper format
        myPos = verifyPos(myPos.toLowerCase(), true);
        atPos = verifyPos(atPos.toLowerCase(), false);

        // Tooltip trigger action
        var showEvent = redux.args.hints.tip_effect.show.event;
        var hideEvent = redux.args.hints.tip_effect.hide.event;

        // Tip show effect
        var tipShowEffect   = redux.args.hints.tip_effect.show.effect;
        var tipShowDuration = redux.args.hints.tip_effect.show.duration;

        // Tip hide effect
        var tipHideEffect   = redux.args.hints.tip_effect.hide.effect;
        var tipHideDuration = redux.args.hints.tip_effect.hide.duration;

        $('div.redux-qtip').each(function() {
            $(this).qtip({
                content: {
                    text:   $(this).attr('qtip-content'),
                    title:  $(this).attr('qtip-title')
                },
                show: {
                    effect: function() {
                        switch (tipShowEffect) {
                            case 'slide':
                                $(this).slideDown(tipShowDuration);
                                break;
                            case 'fade':
                                $(this).fadeIn(tipShowDuration);
                                break;
                            default:
                                $(this).show();
                                break;
                        }
                    },
                    event: showEvent,
                },
                hide: {
                    effect: function() {
                        switch (tipHideEffect) {
                            case 'slide':
                                $(this).slideUp(tipHideDuration);
                                break;
                            case 'fade':
                                $(this).fadeOut(tipHideDuration);
                                break;
                            default:
                                $(this).show(tipHideDuration);
                                break;
                        }
                    },
                    event: hideEvent,
                },
                style: {
                    classes: classes,
                },
                position: {
                    my: myPos,
                    at: atPos,
                },
            });
        });
        // });

        $('input[qtip-content]').each(function() {
            $(this).qtip({
                content: {
                    text:   $(this).attr('qtip-content'),
                    title:  $(this).attr('qtip-title')
                },
                show:   'focus',
                hide:   'blur',
                style:  classes,
                position: {
                    my: myPos,
                    at: atPos,
                },
            });
        });
    }

    $('#toplevel_page_' + redux.args.slug + ' .wp-submenu a, #wp-admin-bar-' + redux.args.slug + ' a.ab-item').click(function(e) {
        if ($('#toplevel_page_' + redux.args.slug).hasClass('wp-menu-open') || $(this).hasClass('ab-item')) {
            e.preventDefault();

            var url = $(this).attr('href').split('&tab=');

            $('#' + url[1] + '_section_group_li_a').click();
            return false;
        }
    });

    /**
     Current tab checks, based on cookies
     **/
    jQuery('.redux-group-tab-link-a').click(function() {
        var relid = jQuery(this).data('rel'); // The group ID of interest
        var oldid = jQuery('.redux-group-tab-link-li.active .redux-group-tab-link-a').data('rel');

        if (oldid === relid) {
            return;
        }
        jQuery('#currentSection').val(relid);
        if (!$(this).parents('.postbox-container:first').length) {
            // Set the proper page cookie
            $.cookie('redux_current_tab', relid, {
                expires:    7,
                path:       '/'
            });
        }

        if (jQuery('#' + relid + '_section_group_li').parents('.redux-group-tab-link-li').length) {
            var parentID = jQuery('#' + relid + '_section_group_li').parents('.redux-group-tab-link-li').attr('id').split('_');
            parentID = parentID[0];
        }

        $('#toplevel_page_' + redux.args.slug + ' .wp-submenu a.current').removeClass('current');
        $('#toplevel_page_' + redux.args.slug + ' .wp-submenu li.current').removeClass('current');

        $('#toplevel_page_' + redux.args.slug + ' .wp-submenu a').each(function() {
            var url = $(this).attr('href').split('&tab=');
            if (url[1] == relid || url[1] == parentID) {
                $(this).addClass('current');
                $(this).parent().addClass('current');
            }
        });

        /**
         if (RELID is child of oldid) {
         oldid activeChild, relid active
         } else if (RELID is sibling of OLDID) {
         remove active of old id, add to relid
         } else {
         if relid is parent {
         slidedown realid
         }
         if oldid is parent {
         slideup oldid
         } else if oldid is child {
         slideup oldid parent and remove class
         } else {
         normal oldid remove active
         }
         }
         **/

        if (jQuery('#' + oldid + '_section_group_li').find('#' + oldid + '_section_group_li').length) {
            //console.log('RELID is child of oldid');
            jQuery('#' + oldid + '_section_group_li').addClass('activeChild');
            jQuery('#' + relid + '_section_group_li').addClass('active').removeClass('activeChild');
        } else if (jQuery('#' + relid + '_section_group_li').parents('#' + oldid + '_section_group_li').length || jQuery('#' + oldid + '_section_group_li').parents('ul.subsection').find('#' + relid + '_section_group_li').length) {
            //console.log('RELID is sibling or child of OLDID');
            if (jQuery('#' + relid + '_section_group_li').parents('#' + oldid + '_section_group_li').length) {
                //console.log('child of oldid');
                jQuery('#' + oldid + '_section_group_li').addClass('activeChild').removeClass('active');
            } else {
                //console.log('sibling');
                jQuery('#' + relid + '_section_group_li').addClass('active');
                jQuery('#' + oldid + '_section_group_li').removeClass('active');
            }
            jQuery('#' + relid + '_section_group_li').removeClass('activeChild').addClass('active');
        } else {
            jQuery('#' + relid + '_section_group_li').addClass('active').removeClass('activeChild').find('ul.subsection').slideDown();
            if (jQuery('#' + oldid + '_section_group_li').find('ul.subsection').length) {
                //console.log('oldid is parent')
                jQuery('#' + oldid + '_section_group_li').find('ul.subsection').slideUp('fast', function() {
                    jQuery('#' + oldid + '_section_group_li').removeClass('active').removeClass('activeChild');
                });
            } else if (jQuery('#' + oldid + '_section_group_li').parents('ul.subsection').length) {
                //console.log('oldid is a child');
                if (!jQuery('#' + oldid + '_section_group_li').parents('#' + relid + '_section_group_li').length) {
                    //console.log('oldid is child, but not of relid');
                    jQuery('#' + oldid + '_section_group_li').parents('ul.subsection').slideUp('fast', function() {
                        jQuery('#' + oldid + '_section_group_li').removeClass('active');
                        jQuery('#' + oldid + '_section_group_li').parents('.redux-group-tab-link-li').removeClass('active').removeClass('activeChild');
                    });
                } else {
                    jQuery('#' + oldid + '_section_group_li').removeClass('active');
                }

            } else {
                //console.log('Normal remove active from child');
                jQuery('#' + oldid + '_section_group_li').removeClass('active');
                if (jQuery('#' + relid + '_section_group_li').parents('.redux-group-tab-link-li').length) {
                    //console.log('here');
                    jQuery('#' + relid + '_section_group_li').parents('.redux-group-tab-link-li').addClass('activeChild').find('ul.subsection').slideDown();
                    jQuery('#' + relid + '_section_group_li').addClass('active');
                }
            }
        }

        // Show the group
        jQuery('#' + oldid + '_section_group').hide();
        jQuery('#' + relid + '_section_group').fadeIn(200, function() {
            if (jQuery('#redux-footer').length !== 0) {
                stickyInfo(); // race condition fix
            }
        });

    });

    // Get the URL parameter for tab
    function getURLParameter(name) {
        return decodeURI((new RegExp(name + '=' + '(.+?)(&|$)').exec(location.search) || [, ''])[1]);
    }

    // If the $_GET param of tab is set, use that for the tab that should be open
    var tab = getURLParameter('tab');

    if (tab !== "") {
        if ($.cookie("redux_current_tab_get") !== tab) {
            $.cookie('redux_current_tab', tab, {
                expires:    7,
                path:       '/'
            });
            $.cookie('redux_current_tab_get', tab, {
                expires:    7,
                path:       '/'
            });

            jQuery('#' + tab + '_section_group_li').click();
        }
    } else if ($.cookie('redux_current_tab_get') !== "") {
        $.removeCookie('redux_current_tab_get');
    }

    var sTab = jQuery('#' + $.cookie("redux_current_tab") + '_section_group_li_a');

    // Tab the first item or the saved one
    if ($.cookie("redux_current_tab") === null || typeof ($.cookie("redux_current_tab")) === "undefined" || sTab.length === 0) {
        jQuery('.redux-group-tab-link-a:first').click();
    } else {
        sTab.click();
    }

    // Default button clicked
    jQuery('input[name="' + redux.args.opt_name + '[defaults]"]').click(function() {
        if (!confirm(redux.args.reset_confirm)) {
            return false;
        }
        window.onbeforeunload = null;
    });

    // Default button clicked
    jQuery('input[name="' + redux.args.opt_name + '[defaults-section]"]').click(function() {
        if (!confirm(redux.args.reset_section_confirm)) {
            return false;
        }

        window.onbeforeunload = null;
    });

    function redux_expand_options(parent) {
        //console.log('here');
        var trigger = parent.find('.expand_options');
        var width   = parent.find('.redux-sidebar').width();
        var id      = jQuery('.redux-group-menu .active a').data('rel') + '_section_group';

        if (trigger.hasClass('expanded')) {
            trigger.removeClass('expanded');
            parent.find('.redux-main').removeClass('expand');
            parent.find('.redux-sidebar').stop().animate({
                'margin-left': '0px'
            }, 500);

            parent.find('.redux-main').stop().animate({
                'margin-left': width
            }, 500);

            parent.find('.redux-group-tab').each(function() {
                if (jQuery(this).attr('id') !== id) {
                    jQuery(this).fadeOut('fast');
                }
            });
            // Show the only active one
        } else {
            trigger.addClass('expanded');
            parent.find('.redux-main').addClass('expand');
            parent.find('.redux-sidebar').stop().animate({
                'margin-left': -width - 102
            }, 500);

            parent.find('.redux-main').stop().animate({
                'margin-left': '0px'
            }, 500);

            parent.find('.redux-group-tab').fadeIn();
        }
        return false;
    }

    jQuery('.expand_options').click(function(e) {
        e.preventDefault();

        redux_expand_options(jQuery(this).parents('.redux-container:first'));
        return false;
    });

    if (jQuery('.saved_notice').is(':visible')) {
        jQuery('.saved_notice').slideDown();
    }

    jQuery(document.body).on('change', '.redux-field input, .redux-field textarea, .redux-field select', function() {
        if (!jQuery(this).hasClass('noUpdate')) {
            redux_change(jQuery(this));
        }
    });

    /**
     BEGIN Sticky footer bar
     **/
    var stickyHeight = jQuery('#redux-footer').height();
    jQuery('#redux-sticky-padder').css({
        height: stickyHeight
    });

    window.onresize = function(event) {
        if (jQuery('#redux-sticky').hasClass('sticky-save-warn')) {
            //console.log('resize');
            //   jQuery('.redux-save-warn').css('left', jQuery('#redux-intro-text').width())
        }
    };

    function stickyInfo() {
        var stickyWidth = jQuery('#info_bar').width() - 2;

        if (!jQuery('#info_bar').isOnScreen() && !jQuery('#redux-footer-sticky').isOnScreen()) {
            jQuery('#redux-sticky').addClass('sticky-save-warn');

            jQuery('#redux-footer').css({
                position:   'fixed',
                bottom:     '0',
                width:      stickyWidth
            });

            jQuery('#redux-footer').addClass('sticky-footer-fixed');
            jQuery('.redux-save-warn').css('left', jQuery('#redux-sticky').offset().left);
            jQuery('#redux-sticky-padder').show();
        } else {
            jQuery('#redux-sticky').removeClass('sticky-save-warn');

            jQuery('#redux-footer').css({
                background: '#eee',
                position:   'inherit',
                bottom:     'inherit',
                width:      'inherit'
            });

            jQuery('#redux-sticky-padder').hide();
            jQuery('#redux-footer').removeClass('sticky-footer-fixed');
        }
    }

    if (jQuery('#redux-footer').length !== 0) {
        jQuery(window).scroll(function() {
            stickyInfo();
        });

        jQuery(window).resize(function() {
            stickyInfo();
        });
    }
    jQuery('.saved_notice').delay(4000).slideUp();
    //jQuery('.redux-field-errors').delay(8000).slideUp();
    jQuery('.redux-save').click(function() {
        window.onbeforeunload = null;
    });
    /**
     END Sticky footer bar
     **/

    /**
     BEGIN dev_mode commands
     **/
    $('#consolePrintObject').on('click', function() {
        console.log(jQuery.parseJSON(jQuery("#redux-object-json").html()));
    });

    if (typeof jsonView === 'function') {
        jsonView('#redux-object-json', '#redux-object-browser');
    }
    /**
     END dev_mode commands
     **/

    /**
     BEGIN error and warning notices
     **/
    if (redux.errors !== undefined) {
        jQuery.each(redux.errors.errors, function(sectionID, sectionArray) {
            jQuery.each(sectionArray.errors, function(key, value) {
                jQuery("#" + redux.args.opt_name + '-' + value.id).addClass("redux-field-error");
                if (jQuery("#" + redux.args.opt_name + '-' + value.id).parent().find('.redux-th-error').length === 0) {
                    jQuery("#" + redux.args.opt_name + '-' + value.id).append('<div class="redux-th-error">' + value.msg + '</div>');
                }
            });

        });
        $('.redux-container').each(function () {
            var container = $(this);
            var totalErrors = container.find('.redux-field-error').length;
            if (totalErrors > 0) {
                container.find(".redux-field-errors span").text(totalErrors);
                container.find(".redux-field-errors").slideDown();
                container.find('.redux-group-tab').each(function () {
                    var total = $(this).find('.redux-field-error').length;
                    if (total > 0 ) {
                        var sectionID = $(this).attr('id').split('_');
                        sectionID = sectionID[0];
                        container.find('.redux-group-tab-link-a:eq('+sectionID+')').prepend('<span class="redux-menu-error">' + total + '</span>');
                        container.find('.redux-group-tab-link-a:eq('+sectionID+')').addClass("hasError");
                    }
                });
            }
            var totalWarnings = container.find('.redux-field-warning').length;
            if (totalWarnings > 0) {
                container.find(".redux-field-warnings span").text(totalWarnings);
                container.find(".redux-field-warnings").slideDown();
                container.find('.redux-group-tab').each(function () {
                    var warning = $(this).find('.redux-field-warning').length;
                    if (warning > 0 ) {
                        var sectionID = $(this).attr('id').split('_');
                        sectionID = sectionID[0];
                        container.find('.redux-group-tab-link-a:eq('+sectionID+')').prepend('<span class="redux-menu-warning">' + total + '</span>');
                        container.find('.redux-group-tab-link-a:eq('+sectionID+')').addClass("hasWarning");
                    }
                });

            }
        });
    }

    /**
     END error and warning notices
     **/

    /**
     BEGIN Control the tabs of the site to the left. Eventually (perhaps) across the top too.
     **/
    //jQuery( ".redux-section-tabs" ).tabs();
    jQuery('.redux-section-tabs div').hide();
    jQuery('.redux-section-tabs div:first').show();
    jQuery('.redux-section-tabs ul li:first').addClass('active');

    jQuery('.redux-section-tabs ul li a').click(function() {
        jQuery('.redux-section-tabs ul li').removeClass('active');
        jQuery(this).parent().addClass('active');

        var currentTab = $(this).attr('href');

        jQuery('.redux-section-tabs div').hide();
        jQuery(currentTab).fadeIn();

        return false;
    });
    /**
     END Control the tabs of the site to the left. Eventually (perhaps) across the top too.
     **/
});